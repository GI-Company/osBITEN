<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OBPI - Operational in Browser Persisted Instance v1.0 (Full Features)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
  <script defer src="https://pyscript.net/latest/pyscript.js"></script>
  <style>
    :root {
      bg-color: #1a1a2e;
      --window-bg: rgba(245, 245, 245, 0.97);
      --window-border: #909090;
      --window-header-bg: #2c2f3b;
      --text-color-dark: #1f2937;
      --text-color-light: #e5e7eb;
      --accent-color: #6366f1; /* Indigo-500 */
      --accent-color-darker: #4f46e5; /* Indigo-600 */
      --taskbar-bg: rgba(25, 28, 38, 0.98);
      --font-main: 'Inter', sans-serif;
      --font-mono: 'Roboto Mono', monospace;
      /* PEPx Specific Colors from its original CSS */
      --pepx-primary-color: #3498db;
      --pepx-secondary-color: #2980b9;
      --pepx-bg-color: #f5f5f5;
      --pepx-light-bg: #ffffff;
      --pepx-text-color: #333;
      --pepx-border-color: #ddd;
    }
    body.light-theme {
      --bg-color: #e0e0e0;
      --window-bg: rgba(255, 255, 255, 0.98);
      --window-border: #c0c0c0;
      --window-header-bg: #52525b;
      --text-color-dark: #18181b;
      --text-color-light: #f8fafc;
      --taskbar-bg: rgba(200, 200, 210, 0.98);
      /* PEPx light theme adjustments */
      --pepx-primary-color: #3498db;
      --pepx-secondary-color: #2980b9;
      --pepx-bg-color: #f0f0f0;
      --pepx-light-bg: #ffffff;
      --pepx-text-color: #333;
      --pepx-border-color: #ccc;
    }
    body.light-theme #desktop { background-color: var(--bg-color); }
    body.light-theme .taskbar { background-color: var(--taskbar-bg); border-top: 1px solid #a0a0b0; }
    body.light-theme .taskbar-button { background-color: rgba(0,0,0,0.1); color: var(--text-color-dark); }
    body.light-theme .taskbar-button:hover { background-color: rgba(0,0,0,0.2); }
    body.light-theme .os-window { background-color: var(--window-bg); border-color: var(--window-border); color: var(--text-color-dark); }
    body.light-theme .window-header { background-color: var(--window-header-bg); color: var(--text-color-light); }
    body.light-theme .window-content { background-color: #ffffff; color: var(--text-color-dark); }
    body.light-theme #window-terminal .window-content { background-color: #f0f0f0; color: #121212; }
    body.light-theme #terminal-prompt { color: #2563eb; }
    body.light-theme #terminal-input { color: #121212; caret-color: #121212; }
    body.light-theme #pyscript-output-area, body.light-theme #pyide-output-area { background-color: #f9f9f9; color: #333; border-color: #ddd; }
    body.light-theme #pyscript-code-area, body.light-theme #pyide-code-area { background-color: #fff; color: #333; border-color: #ccc; }
    body.light-theme #window-ai-assistant .window-content { background-color: #e5e7eb; color: #1f2937; }
    body.light-theme .ai-message.user { background-color: var(--accent-color); }
    body.light-theme .ai-message.assistant { background-color: #d1d5db; }
    body.light-theme .desktop-icon span { color: var(--text-color-dark); text-shadow: 1px 1px 1px #fff; }
    /* PEPx light theme specific window content */
    body.light-theme #window-pepx-explorer .window-content { background-color: var(--pepx-bg-color); color: var(--pepx-text-color); }
    body.light-theme #window-pepx-explorer .pepx-toolbar { background-color: #e8e8e8; border-bottom-color: var(--pepx-border-color); }
    body.light-theme #window-pepx-explorer .pepx-toolbar button { background-color: var(--pepx-primary-color); }
    body.light-theme #window-pepx-explorer .pepx-toolbar button:hover { background-color: var(--pepx-secondary-color); }
    body.light-theme #window-pepx-explorer .pepx-file-list { /* No specific change, inherits window content bg */ }
    body.light-theme #window-pepx-explorer .pepx-item:hover { background-color: rgba(0,0,0,0.03); }
    body.light-theme #window-pepx-explorer .pepx-status-bar { background-color: #e8e8e8; border-top-color: var(--pepx-border-color); color: #444; }


    body { font-family: var(--font-main); overflow: hidden; background-color: var(--bg-color); color: var(--text-color-light); }
    .cli-font { font-family: var(--font-mono); }
    .os-window { min-width: 320px; min-height: 220px; background-color: var(--window-bg); border: 1px solid var(--window-border); box-shadow: 0 6px 20px rgba(0,0,0,0.3); position: absolute; display: flex; flex-direction: column; border-radius: 10px; overflow: hidden; resize: both; }
    .os-window.active-window { border-color: var(--accent-color); box-shadow: 0 8px 25px rgba(0,0,0,0.35); }
    .window-header { background-color: var(--window-header-bg); color: var(--text-color-light); padding: 10px 15px; cursor: move; display: flex; justify-content: space-between; align-items: center; border-top-left-radius: 9px; border-top-right-radius: 9px; user-select: none; }
    .window-title { font-weight: 600; font-size: 0.95rem; }
    .window-controls button { background: none; border: none; color: var(--text-color-light); font-size: 1.2rem; padding: 2px 5px; margin-left: 7px; cursor: pointer; border-radius: 4px; line-height: 1; }
    .window-controls button:hover { background-color: rgba(255,255,255,0.15); }
    .window-content { flex-grow: 1; padding: 0; /* Remove padding for apps that manage their own */ overflow: auto; background-color: var(--window-bg); color: var(--text-color-dark); }
    .window-content iframe { width: 100%; height: 100%; border: none; }
    #desktop { width: 100vw; height: 100vh; position: relative; overflow: hidden; padding: 10px; display: flex; flex-direction: column; flex-wrap: wrap; align-content: flex-start; gap:10px; }
    .desktop-icon { display: flex; flex-direction: column; align-items: center; width: 80px; padding: 5px; border-radius: 5px; cursor: pointer; text-align: center; user-select:none; }
    .desktop-icon:hover { background-color: rgba(255,255,255,0.1); }
    .desktop-icon img, .desktop-icon .icon-placeholder { width: 48px; height: 48px; margin-bottom: 5px; object-fit: contain; }
    .desktop-icon .icon-placeholder { font-size: 32px; display:flex; align-items:center; justify-content:center; background-color: rgba(255,255,255,0.05); border-radius:4px; }
    .desktop-icon span { font-size: 0.75rem; color: var(--text-color-light); word-break: break-word; line-height: 1.2; max-height: 2.4em; overflow:hidden; }

    #webgl-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -10; }
    .taskbar { position: fixed; bottom: 0; left: 0; width: 100%; height: 50px; background-color: var(--taskbar-bg); display: flex; align-items: center; padding: 0 12px; z-index: 10000; border-top: 1px solid rgba(255,255,255,0.1); }
    .taskbar-button { background-color: rgba(255,255,255,0.1); color: var(--text-color-light); padding: 7px 14px; margin-right: 8px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s; font-size: 0.85rem; border: 1px solid transparent; }
    .taskbar-button:hover { background-color: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.3); }
    #start-menu { position: fixed; bottom: 50px; left: 0; background-color: var(--taskbar-bg); border: 1px solid rgba(255,255,255,0.2); border-bottom:none; border-top-right-radius: 8px; padding: 10px; z-index: 9999; min-width: 250px; box-shadow: 0 -5px 15px rgba(0,0,0,0.2); }
    .start-menu-item { display: block; padding: 8px 12px; color: var(--text-color-light); text-decoration: none; border-radius: 4px; font-size:0.9rem; }
    .start-menu-item:hover { background-color: var(--accent-color); }

    .context-menu { position: absolute; background-color: #fff; border: 1px solid #ccc; box-shadow: 0 4px 15px rgba(0,0,0,0.2); border-radius: 6px; padding: 8px 0; z-index: 20000; min-width: 180px; }
    .context-menu-item { padding: 10px 20px; cursor: pointer; font-size: 0.9rem; color: #333; }
    .context-menu-item:hover { background-color: #f0f0f0; }
    /* Terminal Specific - padding handled by #window-terminal .window-content */
    #window-terminal .window-content { background-color: #121212; color: #e0e0e0; padding: 12px; display: flex; flex-direction: column-reverse; }
    #terminal-output { white-space: pre-wrap; word-break: break-all; flex-grow: 1; }
    #terminal-input-line { display: flex; align-items: center; padding-top: 6px; }
    #terminal-prompt { color: #00aaff; margin-right: 8px; }
    #terminal-input { background-color: transparent; border: none; color: #f0f0f0; outline: none; flex-grow: 1; caret-color: #f0f0f0; }

    /* AI Assistant Specific - padding handled by #window-ai-assistant .window-content */
    #window-ai-assistant .window-content { display: flex; flex-direction: column; background-color: #252a34; color: #e0e0e0; padding:0; }
    #ai-chat-output { flex-grow: 1; overflow-y: auto; padding: 12px; border-bottom: 1px solid #3a3f4b; }
    .ai-message { margin-bottom: 12px; padding: 10px 14px; border-radius: 8px; max-width: 85%; word-wrap: break-word; line-height: 1.5; }
    .ai-message.user { background-color: var(--accent-color); color: white; margin-left: auto; text-align: left; }
    .ai-message.assistant { background-color: #3a3f4b; margin-right: auto; }
    #ai-input-area { display: flex; padding: 12px; border-top: 1px solid #3a3f4b;}
    #ai-input { flex-grow: 1; padding: 10px 12px; border-radius: 6px; border: 1px solid #4a4f5a; background-color: #3a3f4b; color: #e0e0e0; outline: none; }
    #ai-send-button { margin-left: 10px; padding: 10px 18px; background-color: var(--accent-color); color: white; border: none; border-radius: 6px; cursor: pointer; }
    #ai-send-button:hover { background-color: var(--accent-color-darker); }

    /* AI Assistant - Tabs for Chat / Hex Converter */
    .ai-tabs { display: flex; border-bottom: 1px solid #3a3f4b; background-color: #2c2f3b; }
    .ai-tab-button { padding: 10px 15px; cursor: pointer; color: var(--text-color-light); border-right: 1px solid #3a3f4b; }
    .ai-tab-button.active { background-color: var(--window-header-bg); font-weight: bold; border-bottom: 2px solid var(--accent-color); }
    .ai-tab-content { flex-grow: 1; display: none; flex-direction: column; padding: 12px; }
    .ai-tab-content.active { display: flex; }

    /* Hex Converter specific styles */
    #hex-converter-content { padding: 12px; }
    #hex-converter-content textarea { width: 100%; height: 150px; padding: 8px; border-radius: 6px; border: 1px solid #4a4f5a; background-color: #3a3f4b; color: #e0e0e0; outline: none; margin-bottom: 10px; }
    #hex-converter-content button { padding: 8px 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 6px; cursor: pointer; margin-right: 10px; }
    #hex-converter-content button:hover { background-color: var(--accent-color-darker); }
    #hex-converter-output { background-color: #1e1e1e; color: #e0e0e0; border: 1px solid #333; padding: 8px; border-radius: 4px; overflow-y: auto; white-space: pre-wrap; font-family: var(--font-mono); min-height: 100px; }

    /* Disk Manager Specific - padding handled by #window-disk-manager .window-content */
    #window-disk-manager .window-content { padding: 15px; }
    .volume-item { background-color: #e9ecef; padding: 10px; border-radius: 5px; margin-bottom:10px; border: 1px solid #ced4da;}
    .volume-item strong { color: var(--accent-color); }

    /* Ncurses App Specific - padding handled by #window-ncurses-app .window-content */
    #window-ncurses-app .window-content { background-color: #000033; color: #c0c0c0; font-family: 'Courier New', Courier, monospace; padding: 5px; overflow: hidden; }
    .ncurses-char { display: inline-block; width: 0.6em; text-align: center; }

    /* Python Runner & PyIDE Specific - padding handled by window content */
    #window-python-runner .window-content, #window-py-ide .window-content { display: flex; flex-direction: column; gap: 10px; padding:10px; }
    #python-code-area, #pyide-code-area { font-family: var(--font-mono); flex-grow: 1; border: 1px solid #ccc; padding: 8px; border-radius: 4px; background-color: #fdfdfd; color: #333; }
    #python-output-area, #pyide-output-area { height: 150px; background-color: #1e1e1e; color: #e0e0e0; border: 1px solid #333; padding: 8px; border-radius: 4px; overflow-y: auto; white-space: pre-wrap; font-family: var(--font-mono); }

    .fullscreen-lock-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0,0,0,0.3); z-index: 9999; display: none; }
    body:fullscreen #fullscreen-lock-overlay, body:-webkit-full-screen #fullscreen-lock-overlay { display: block; }
    #window-network-manager .window-content ul, #window-bluetooth-manager .window-content ul { list-style: none; padding:0; }
    #window-network-manager .window-content li, #window-bluetooth-manager .window-content li { background-color: #e9ecef; padding: 8px; margin-bottom: 5px; border-radius: 4px; display:flex; justify-content: space-between; align-items:center; }
    #window-network-manager .window-content, #window-bluetooth-manager .window-content { padding: 15px; }

    /* Peripheral Manager Specific */
    #window-peripheral-manager .window-content { padding: 15px; }
    #window-peripheral-manager .device-list-item { background-color: #e9ecef; padding: 8px; margin-bottom: 5px; border-radius: 4px; display:flex; justify-content: space-between; align-items:center; color: var(--text-color-dark); }
    #window-peripheral-manager .device-list-item span { font-weight: 500; }
    #window-peripheral-manager .device-list-item .status { font-size: 0.8em; color: #666; }


    /* PEPx File Explorer Specific Styles */
    #window-pepx-explorer .window-content {
      padding: 0; /* PEPx manages its own internal padding */
      background-color: var(--pepx-bg-color);
      color: var(--pepx-text-color);
      height: 100%; /* Ensure it fills the window content area */
    }
    .pepx-file-manager { display: flex; flex-direction: column; height: 100%; border: none; /* Removed border as it's inside a window */ border-radius: 0; overflow: hidden; }
    .pepx-toolbar { display: flex; padding: 10px; background-color: #f0f0f0; border-bottom: 1px solid var(--pepx-border-color); align-items: center; }
    .pepx-toolbar button { background-color: var(--pepx-primary-color); color: white; border: none; border-radius: 4px; padding: 6px 10px; margin-right: 8px; cursor: pointer; font-size: 0.8rem; }
    .pepx-toolbar button:hover { background-color: var(--pepx-secondary-color); }
    .pepx-toolbar input#pepx-path-display { flex-grow: 1; padding: 6px; border: 1px solid var(--pepx-border-color); border-radius: 4px; font-size: 0.8rem; background-color: var(--pepx-light-bg); color: var(--pepx-text-color); }
    .pepx-file-list { flex-grow: 1; overflow-y: auto; padding: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; background-color: var(--pepx-light-bg); }
    .pepx-item { display: flex; flex-direction: column; align-items: center; padding: 8px; cursor: pointer; border-radius: 5px; transition: background-color 0.2s; border: 1px solid transparent; }
    .pepx-item:hover { background-color: rgba(0, 0, 0, 0.05); border-color: var(--pepx-border-color); }
    .pepx-icon { font-size: 28px; margin-bottom: 4px; }
    .pepx-name { text-align: center; font-size: 11px; word-break: break-word; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; line-height:1.2; }
    .pepx-size { font-size: 9px; color: #777; margin-top: 2px; }
    .pepx-status-bar { padding: 6px 10px; background-color: #f0f0f0; border-top: 1px solid var(--pepx-border-color); display: flex; justify-content: space-between; font-size: 11px; color: #555; }
    /* PEPx Modal (re-using OBPI's modal for consistency, but can be styled uniquely if needed) */
    .pepx-modal-body img { max-width: 100%; display: block; margin: 0 auto; border-radius: 4px; }
    .pepx-modal-body pre { white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: var(--font-mono); background-color: #f8f8f8; padding:10px; border-radius:4px; max-height: 60vh; overflow-y:auto; }
    /* PEPx Context Menu (re-using OBPI's for consistency) */

    /* Browser specific styles */
    #window-web-view .window-content {
      display: flex;
      flex-direction: column;
      background-color: white;
      color: black;
      padding: 0;
    }
    #web-view-search-bar {
      display: flex;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid #e0e0e0;
      background-color: #f8f8f8;
      gap: 8px;
    }
    #web-view-search-bar button {
      padding: 6px 10px;
      border-radius: 5px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    #web-view-search-bar .nav-btn {
      background-color: #e0e0e0;
      color: #333;
    }
    #web-view-search-bar .nav-btn:hover {
      background-color: #d0d0d0;
    }
    #web-view-search-bar .url-input {
      flex-grow: 1;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 0.9rem;
    }
    #web-view-search-bar .go-btn {
      background-color: var(--accent-color);
      color: white;
    }
    #web-view-search-bar .go-btn:hover {
      background-color: var(--accent-color-darker);
    }
    #web-view-iframe {
      flex-grow: 1;
      width: 100%;
      border: none;
    }
    #web-view-tabs {
      display: flex;
      border-bottom: 1px solid #e0e0e0;
      background-color: #f0f0f0;
      overflow-x: auto;
    }
    .web-view-tab {
      padding: 8px 12px;
      cursor: pointer;
      border-right: 1px solid #e0e0e0;
      background-color: #e8e8e8;
      font-size: 0.85rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 150px;
    }
    .web-view-tab.active {
      background-color: white;
      border-bottom: 2px solid var(--accent-color);
      font-weight: 600;
    }
    .web-view-tab .close-tab-btn {
      margin-left: 8px;
      color: #888;
      font-weight: bold;
      cursor: pointer;
    }
    .web-view-tab .close-tab-btn:hover {
      color: #333;
    }
    .web-view-tab-add {
      padding: 8px 12px;
      cursor: pointer;
      background-color: #f0f0f0;
      border-right: 1px solid #e0e0e0;
      font-size: 0.85rem;
    }
    .web-view-tab-add:hover {
      background-color: #e0e0e0;
    }
    .browser-history-list, .browser-bookmarks-list {
      max-height: 400px;
      overflow-y: auto;
      padding: 10px;
      background-color: #f9f9f9;
      border-radius: 5px;
      margin-top: 10px;
      color: var(--text-color-dark);
    }
    .browser-history-item, .browser-bookmark-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }
    .browser-history-item:last-child, .browser-bookmark-item:last-child {
      border-bottom: none;
    }
    .browser-history-item:hover, .browser-bookmark-item:hover {
      background-color: #f0f0f0;
    }
    .browser-history-item .url, .browser-bookmark-item .url {
      font-size: 0.8em;
      color: #666;
      word-break: break-all;
    }
    .browser-bookmark-item .delete-btn {
      float: right;
      color: red;
      cursor: pointer;
      font-size: 0.9em;
      margin-left: 10px;
    }

  </style>
</head>
<body>

<div id="desktop">
  <canvas id="webgl-canvas"></canvas>
  <div id="fullscreen-lock-overlay" class="fullscreen-lock-overlay"></div>
</div>

<div class="taskbar">
  <button id="start-menu-button" class="taskbar-button"> OBPI</button>
  <div id="taskbar-apps-container" style="display: flex; margin-left: 10px;"></div>
</div>

<div id="start-menu" class="hidden">
</div>

<div id="context-menu" class="context-menu hidden"></div>

<div id="generic-modal" class="fixed inset-0 bg-black bg-opacity-60 items-center justify-center z-[15000] hidden">
  <div class="bg-white p-6 rounded-lg shadow-xl max-w-md w-full text-gray-800">
    <div class="flex justify-between items-center mb-4">
      <h3 id="modal-title" class="text-xl font-semibold">Modal Title</h3>
      <button id="modal-close-button" class="text-2xl hover:text-red-500">&times;</button>
    </div>
    <div id="modal-content" class="mb-4"><p>Modal content goes here...</p></div>
    <div id="modal-actions" class="flex justify-end space-x-3"></div>
  </div>
</div>
</script>
<pyscript>
  // --- OBPI (Operational in Browser Persisted Instance) Core v1.0 (Full Features) ---
  // [2025-05-23]
  // Full integration of AI assistant, enhanced terminal, real USB peripheral detection,
  // and re-architected PEPx storage (no client-side canvas for data).
  // Conceptual compiler framework for various languages and hex-to-webgl.

  // --- Global State & Configuration ---
  const OBPI = {
    version: "1.0-full-features",
    name: "Operational in Browser Persisted Instance",
    desktopElement: document.getElementById('desktop'),
    taskbarElement: document.querySelector('.taskbar'),
    taskbarAppsContainer: document.getElementById('taskbar-apps-container'),
    startMenuElement: document.getElementById('start-menu'),
    startMenuButton: document.getElementById('start-menu-button'),
    contextMenuElement: document.getElementById('context-menu'),
    modalElement: document.getElementById('generic-modal'),
    modalTitle: document.getElementById('modal-title'),
    modalContent: document.getElementById('modal-content'),
    modalActions: document.getElementById('modal-actions'),
    modalCloseButton: document.getElementById('modal-close-button'),
    fullscreenLockOverlay: document.getElementById('fullscreen-lock-overlay'),
    windows: {},
    nextZIndex: 100,
    currentPath: '/', // Start at VFS root
    commandHistory: [],
    commandHistoryIndex: -1,
    isLocked: false,
    envVars: {},
    aliases: {},
    activeTheme: 'dark',
    config: {
      defaultPrompt: 'guest@OBPI:~# ',
      maxTerminalOutputLines: 300,
      defaultWindowSize: { width: '600px', height: '450px' },
      windowStateStorageKey: 'OBPI_window_states_v1.0', // Updated key
      themeStorageKey: 'OBPI_theme_v1.0', // Updated key
      desktopIconStorageKey: 'OBPI_desktop_icons_v1.0', // Updated key
    },
    kernel: {
      // Log messages to Python backend
      log: (message, level = 'info', data = null) => {
        console[level] || console.log(`[OBPI Kernel|${level.toUpperCase()}]: ${message}`, data);
        if (window.pywebview && window.pywebview.api && window.pywebview.api.log_to_python) {
          window.pywebview.api.log_to_python(`[JS]: ${message}`, level);
        }
      },
      // WASM module loading remains conceptual as it's not directly backend-driven
      loadWasmModule: async (url, importObject = {}) => { OBPI.kernel.log(`Attempting to load WASM module from: ${url}`); try { if (url.includes("core_emulator.wasm")) { OBPI.kernel.log(`Simulating load of core_emulator.wasm...`, 'info'); return { add_native: (a, b) => { OBPI.kernel.log(`WASM add_native(${a}, ${b}) called.`); return a + b; }, get_native_greeting: (name) => { OBPI.kernel.log(`WASM get_native_greeting("${name}") called.`); return `[Simulated C->WASM]: Hello, ${name}! Time: ${new Date().toLocaleTimeString()}`; }, get_system_timestamp_native: () => { OBPI.kernel.log(`WASM get_system_timestamp_native() called.`); return Math.floor(Date.now() / 1000); } }; } throw new Error("WASM module not found or simulated path incorrect."); } catch (error) { OBPI.kernel.log(`Error loading WASM module ${url}: ${error.message}`, "error"); throw error; } },
      requestPermission: async (permissionType, appName) => { return new Promise((resolve) => { Modal.confirm('Permission Request', `App "${appName}" requests permission for: ${permissionType}. Allow?`, (granted) => { OBPI.kernel.log(`Permission for '${permissionType}' ${granted ? 'granted' : 'denied'} to '${appName}'.`); resolve(granted); }); }); },
      messageBus: { listeners: {}, subscribe: (topic, callback) => { if (!OBPI.kernel.messageBus.listeners[topic]) OBPI.kernel.messageBus.listeners[topic] = []; OBPI.kernel.messageBus.listeners[topic].push(callback); OBPI.kernel.log(`App subscribed to topic: ${topic}`); }, publish: (topic, data) => { if (OBPI.kernel.messageBus.listeners[topic]) { OBPI.kernel.log(`Publishing to topic: ${topic} with data:`, 'info', data); OBPI.kernel.messageBus.listeners[topic].forEach(callback => { try { callback(data); } catch (e) { OBPI.kernel.log(`Error in message bus subscriber for topic ${topic}: ${e.message}`, 'error');} }); } } }
    },
    pepxInstance: null // To hold the global PEPxStorage instance
  };

  // --- Client-Side "EJS-like" Templating Engine (Remains client-side) ---
  const EJSSimulator = {
    render: (templateString, data = {}) => { let rendered = templateString; for (const key in data) { const regex = new RegExp(`<%[=\\-_]?\\s*${key}\\s*%>`, 'g'); rendered = rendered.replace(regex, data[key]); } return rendered; },
    exampleTemplate: ` <div class="p-4 border rounded bg-blue-100 text-blue-800"> <h2 class="text-xl font-bold"><%= title %></h2> <p><%= content %></p> <p>Generated at: <%= timestamp %></p> </div> `,
    renderExample: () => { const data = { title: "EJS Simulated Content", content: "Dynamically rendered using EJSSimulator.", timestamp: new Date().toLocaleTimeString() }; return EJSSimulator.render(EJSSimulator.exampleTemplate, data); }
  };

  // --- Modal Manager ---
  const Modal = {
    show: (title, contentHTML, actions = [{ text: 'OK', type: 'primary', handler: () => Modal.hide() }]) => { OBPI.modalTitle.textContent = title; if (typeof contentHTML === 'string') OBPI.modalContent.innerHTML = contentHTML; else { OBPI.modalContent.innerHTML = ''; OBPI.modalContent.appendChild(contentHTML); } OBPI.modalActions.innerHTML = ''; actions.forEach(action => { const button = document.createElement('button'); button.textContent = action.text; button.className = `px-4 py-2 rounded-md text-sm font-medium ${ action.type === 'danger' ? 'bg-red-500 hover:bg-red-600 text-white' : action.type === 'secondary' ? 'bg-gray-200 hover:bg-gray-300 text-gray-700' : 'bg-indigo-600 hover:bg-indigo-700 text-white' }`; button.onclick = () => { if(action.handler) action.handler(); if(action.hideOnClick !== false) Modal.hide(); }; OBPI.modalActions.appendChild(button); }); OBPI.modalElement.classList.remove('hidden'); OBPI.modalElement.classList.add('flex'); },
    hide: () => { OBPI.modalElement.classList.add('hidden'); OBPI.modalElement.classList.remove('flex'); },
    prompt: (title, labelText, defaultValue = '', callback) => { const promptContent = document.createElement('div'); const label = document.createElement('label'); label.textContent = labelText; label.className = 'block text-sm font-medium text-gray-700 mb-1'; const input = document.createElement('input'); input.type = 'text'; input.value = defaultValue; input.className = 'w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500'; promptContent.appendChild(label); promptContent.appendChild(input); Modal.show(title, promptContent, [ { text: 'Cancel', type: 'secondary', handler: () => callback(null) }, { text: 'OK', type: 'primary', handler: () => callback(input.value) } ]); setTimeout(() => input.focus(), 50); },
    confirm: (title, message, callback) => { Modal.show(title, `<p>${message}</p>`, [ { text: 'Cancel', type: 'secondary', handler: () => callback(false) }, { text: 'OK', type: 'primary', handler: () => callback(true) } ]); }
  };
  OBPI.modalCloseButton.onclick = Modal.hide;

  // --- WebGL Background ---
  function initWebGLBackground() {
    try {
      scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000); renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webgl-canvas'), antialias: true, alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(OBPI.config.bgColor || 0x1a1a2e, 1); const starGeometry = new THREE.BufferGeometry(); const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, sizeAttenuation: true, transparent: true, opacity: 0.7 }); const starVertices = []; for (let i = 0; i < 15000; i++) { const x = THREE.MathUtils.randFloatSpread(2000); const y = THREE.MathUtils.randFloatSpread(2000); const z = THREE.MathUtils.randFloatSpread(2000); starVertices.push(x, y, z); } starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3)); stars = new THREE.Points(starGeometry, starMaterial); scene.add(stars); camera.position.z = 1; function animate() { requestAnimationFrame(animate); stars.rotation.x += 0.00005; stars.rotation.y += 0.0001; renderer.render(scene, camera); } animate(); window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }); OBPI.kernel.log("WebGL background initialized.", "success");
    } catch (e) { OBPI.kernel.log(`WebGL initialization failed: ${e.message}`, "error"); OBPI.desktopElement.style.backgroundColor = OBPI.config.bgColor || '#1a1a2e'; }
  }

  // --- Window Management Module ---
  const WindowManager = {
    create: (id, title, contentHTML = '', options = {}) => { if (OBPI.windows[id]) { WindowManager.focus(id); return OBPI.windows[id].element; } const windowElement = document.createElement('div'); windowElement.id = `window-${id}`; windowElement.classList.add('os-window'); const defaultSize = OBPI.config.defaultWindowSize; const persistedStates = WindowManager.loadWindowStates(); const state = persistedStates[id] || {}; windowElement.style.width = state.width || options.width || defaultSize.width; windowElement.style.height = state.height || options.height || defaultSize.height; windowElement.style.top = state.top || options.top || `${Math.random() * 80 + 20}px`; windowElement.style.left = state.left || options.left || `${Math.random() * 120 + 20}px`; windowElement.style.zIndex = state.zIndex || OBPI.nextZIndex++; if (state.zIndex && state.zIndex >= OBPI.nextZIndex) OBPI.nextZIndex = state.zIndex + 1; const header = document.createElement('div'); header.classList.add('window-header'); header.innerHTML = `<span class="window-title">${title}</span><div class="window-controls"><button class="minimize-btn" title="Minimize">─</button><button class="maximize-btn" title="Maximize">□</button><button class="close-btn" title="Close">×</button></div>`; const content = document.createElement('div'); content.classList.add('window-content'); if (options.isRawHTML) content.innerHTML = contentHTML; else if (typeof contentHTML === 'string' && contentHTML.startsWith('<')) content.innerHTML = contentHTML; else if (contentHTML instanceof HTMLElement) content.appendChild(contentHTML); else if (typeof contentHTML === 'string') { const p = document.createElement('p'); p.textContent = contentHTML; content.appendChild(p); } windowElement.appendChild(header); windowElement.appendChild(content); OBPI.desktopElement.appendChild(windowElement); OBPI.windows[id] = { element: windowElement, title: title, minimized: false, originalRect: null, zIndex: parseInt(windowElement.style.zIndex) }; WindowManager.addAppToTaskbar(id, title); let offsetX, offsetY, isDragging = false; let dragTimeout; header.addEventListener('mousedown', (e) => { if (e.target.closest('.window-controls button')) return; isDragging = true; offsetX = e.clientX - windowElement.offsetLeft; offsetY = e.clientY - windowElement.offsetTop; WindowManager.focus(id); }); document.addEventListener('mousemove', (e) => { if (!isDragging) return; let newX = e.clientX - offsetX; let newY = e.clientY - offsetY; const desktopRect = OBPI.desktopElement.getBoundingClientRect(); const taskbarHeight = OBPI.taskbarElement.offsetHeight; newX = Math.max(0, Math.min(newX, desktopRect.width - windowElement.offsetWidth)); newY = Math.max(0, Math.min(newY, desktopRect.height - windowElement.offsetHeight - taskbarHeight)); windowElement.style.left = `${newX}px`; windowElement.style.top = `${newY}px`; }); document.addEventListener('mouseup', () => { if(isDragging) {isDragging = false; WindowManager.saveWindowStates();} }); const resizeObserver = new ResizeObserver(() => { clearTimeout(dragTimeout); dragTimeout = setTimeout(WindowManager.saveWindowStates, 500); }); resizeObserver.observe(windowElement); header.querySelector('.close-btn').onclick = (e) => { e.stopPropagation(); WindowManager.close(id); }; header.querySelector('.minimize-btn').onclick = (e) => { e.stopPropagation(); WindowManager.minimize(id); }; header.querySelector('.maximize-btn').onclick = (e) => { e.stopPropagation(); WindowManager.maximize(id); }; windowElement.onmousedown = () => WindowManager.focus(id); OBPI.kernel.log(`Window created: ${title} (ID: ${id})`); if (state.minimized) WindowManager.minimize(id); return windowElement; },
    focus: (id) => { if (OBPI.windows[id]) { const newZ = OBPI.nextZIndex++; OBPI.windows[id].element.style.zIndex = newZ; OBPI.windows[id].zIndex = newZ; document.querySelectorAll('.os-window').forEach(win => win.classList.remove('active-window')); OBPI.windows[id].element.classList.add('active-window'); if (OBPI.windows[id].minimized) WindowManager.restore(id); WindowManager.saveWindowStates(); } },
    close: (id) => { if (OBPI.windows[id]) { OBPI.windows[id].element.remove(); delete OBPI.windows[id]; WindowManager.removeAppFromTaskbar(id); WindowManager.saveWindowStates(); OBPI.kernel.log(`Window closed: ${id}`); } },
    minimize: (id) => { if (OBPI.windows[id] && !OBPI.windows[id].minimized) { OBPI.windows[id].element.style.display = 'none'; OBPI.windows[id].minimized = true; const taskbarBtn = document.getElementById(`taskbar-${id}`); if(taskbarBtn) taskbarBtn.style.opacity = '0.7'; WindowManager.saveWindowStates(); } },
    restore: (id) => { if (OBPI.windows[id] && OBPI.windows[id].minimized) { OBPI.windows[id].element.style.display = 'flex'; OBPI.windows[id].minimized = false; const taskbarBtn = document.getElementById(`taskbar-${id}`); if(taskbarBtn) taskbarBtn.style.opacity = '1'; WindowManager.focus(id); } },
    maximize: (id) => { const winData = OBPI.windows[id]; if (!winData) return; const winEl = winData.element; const taskbarHeight = OBPI.taskbarElement.offsetHeight; const maximizeBtn = winEl.querySelector('.maximize-btn'); if (winData.originalRect) { winEl.style.width = winData.originalRect.width; winEl.style.height = winData.originalRect.height; winEl.style.top = winData.originalRect.top; winEl.style.left = winData.originalRect.left; winData.originalRect = null; if(maximizeBtn) maximizeBtn.textContent = '□'; } else { winData.originalRect = { width: winEl.style.width, height: winEl.style.height, top: winEl.style.top, left: winEl.style.left }; winEl.style.width = '100%'; winEl.style.height = `calc(100% - ${taskbarHeight}px)`; winEl.style.top = '0px'; winEl.style.left = '0px'; if(maximizeBtn) maximizeBtn.textContent = '❐'; } WindowManager.saveWindowStates(); },
    addAppToTaskbar: (id, title) => { const button = document.createElement('button'); button.id = `taskbar-${id}`; button.classList.add('taskbar-button'); button.textContent = title.substring(0, 10) + (title.length > 10 ? '…' : ''); button.title = title; button.onclick = () => { if (OBPI.windows[id]) { if (OBPI.windows[id].minimized) WindowManager.restore(id); else WindowManager.focus(id); } }; OBPI.taskbarAppsContainer.appendChild(button); },
    removeAppFromTaskbar: (id) => { const button = document.getElementById(`taskbar-${id}`); if (button) button.remove(); },
    saveWindowStates: () => { const states = {}; for (const id in OBPI.windows) { const win = OBPI.windows[id]; if (win.element) { states[id] = { top: win.element.style.top, left: win.element.style.left, width: win.element.style.width, height: win.element.style.height, zIndex: win.zIndex, minimized: win.minimized, }; } } try { localStorage.setItem(OBPI.config.windowStateStorageKey, JSON.stringify(states)); } catch (e) { OBPI.kernel.log('Failed to save window states to localStorage.', 'error'); } },
    loadWindowStates: () => { try { const storedStates = localStorage.getItem(OBPI.config.windowStateStorageKey); return storedStates ? JSON.parse(storedStates) : {}; } catch (e) { OBPI.kernel.log('Failed to load window states from localStorage.', 'error'); return {}; } },
    restoreAllWindowStates: () => { const persistedStates = WindowManager.loadWindowStates(); let maxZ = OBPI.nextZIndex; for (const id in persistedStates) { if (AppManager.installedApps[id] || id === 'terminal' || id === 'welcome-note') { if (persistedStates[id].zIndex > maxZ) maxZ = persistedStates[id].zIndex; } } OBPI.nextZIndex = maxZ +1; OBPI.kernel.log("Window states conceptually loaded. Windows will apply state upon creation if found.", "info"); }
  };

  // --- Terminal Module ---
  const Terminal = {
    outputElement: null, inputElement: null, promptElement: null,
    init: () => { const terminalContent = document.createElement('div'); terminalContent.className = 'cli-font w-full h-full flex flex-col'; Terminal.outputElement = document.createElement('div'); Terminal.outputElement.id = 'terminal-output'; const inputLine = document.createElement('div'); inputLine.id = 'terminal-input-line'; Terminal.promptElement = document.createElement('span'); Terminal.promptElement.id = 'terminal-prompt'; Terminal.updatePrompt(); Terminal.inputElement = document.createElement('input'); Terminal.inputElement.type = 'text'; Terminal.inputElement.id = 'terminal-input'; Terminal.inputElement.setAttribute('autocomplete', 'off'); Terminal.inputElement.setAttribute('autocorrect', 'off'); Terminal.inputElement.setAttribute('autocapitalize', 'off'); Terminal.inputElement.setAttribute('spellcheck', 'false'); inputLine.appendChild(Terminal.promptElement); inputLine.appendChild(Terminal.inputElement); terminalContent.appendChild(Terminal.outputElement); terminalContent.appendChild(inputLine); const termWindow = WindowManager.create('terminal', 'Termia Chronos Shell', terminalContent, {width: '800px', height: '550px'}); Terminal.inputElement.onkeydown = Terminal.handleInput; termWindow.onclick = () => Terminal.inputElement.focus(); Terminal.inputElement.focus(); Terminal.print(`OBPI (${OBPI.name}) v${OBPI.version} [Termia Chronos Shell Ready]`); Terminal.print("Type 'help' for commands. Try 'theme light' or 'theme dark'."); },
    updatePrompt: () => { if (Terminal.promptElement) { let currentDirName = OBPI.currentPath.split('/').filter(Boolean).pop() || '/'; if (OBPI.currentPath === '/') currentDirName = '/'; // Keep '/' for root
    else if (OBPI.currentPath === '/home/guest/') currentDirName = '~'; // Placeholder for default home
      Terminal.promptElement.textContent = OBPI.config.defaultPrompt.replace('~#', `${currentDirName}$ `).replace('guest@OBPI', OBPI.envVars['USER'] || 'guest@OBPI');} },
    print: (message, isCommand = false, type = 'info') => { if (!Terminal.outputElement) return; const line = document.createElement('div'); line.className = 'leading-normal'; if (isCommand) { const promptText = Terminal.promptElement ? Terminal.promptElement.textContent : OBPI.config.defaultPrompt; line.innerHTML = `<span class="text-green-400">${promptText.replace(/</g, "&lt;")}</span><span class="text-gray-300">${message.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</span>`; }  else { let textColor = 'text-gray-300'; if(document.body.classList.contains('light-theme')) { textColor = 'text-gray-700'; if(type==='error') textColor = 'text-red-600'; if(type==='success') textColor = 'text-green-600'; if(type==='warn') textColor = 'text-yellow-600'; } else { if(type === 'error') textColor = 'text-red-400'; if(type === 'success') textColor = 'text-green-400'; if(type === 'warn') textColor = 'text-yellow-400';} line.innerHTML = `<span class="${textColor}">${message.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</span>`; } Terminal.outputElement.prepend(line); while (Terminal.outputElement.children.length > OBPI.config.maxTerminalOutputLines) Terminal.outputElement.removeChild(Terminal.outputElement.lastChild); },
    handleInput: async (e) => { // Made async to await backend calls
      if (e.key === 'Enter') {
        const commandStr = Terminal.inputElement.value.trim();
        Terminal.print(commandStr, true);
        if (commandStr) {
          if (commandStr !== OBPI.commandHistory[0]) OBPI.commandHistory.unshift(commandStr);
          if (OBPI.commandHistory.length > 50) OBPI.commandHistory.pop();
          await AppManager.executeCommand(commandStr); // Await command execution
        }
        OBPI.commandHistoryIndex = -1;
        Terminal.inputElement.value = '';
      }  else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (OBPI.commandHistoryIndex < OBPI.commandHistory.length - 1) {
          OBPI.commandHistoryIndex++;
          Terminal.inputElement.value = OBPI.commandHistory[OBPI.commandHistoryIndex];
          Terminal.inputElement.setSelectionRange(Terminal.inputElement.value.length, Terminal.inputElement.value.length);
        }
      }  else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (OBPI.commandHistoryIndex > 0) {
          OBPI.commandHistoryIndex--;
          Terminal.inputElement.value = OBPI.commandHistory[OBPI.commandHistoryIndex];
          Terminal.inputElement.setSelectionRange(Terminal.inputElement.value.length, Terminal.inputElement.value.length);
        } else {
          OBPI.commandHistoryIndex = -1;
          Terminal.inputElement.value = '';
        }
      }  else if (e.key === 'Tab') {
        e.preventDefault();
        const currentInput = Terminal.inputElement.value;
        const parts = currentInput.split(/\s+/);
        const cmdPart = parts[0].toLowerCase();
        const argPart = parts.length > 1 ? parts[parts.length -1] : '';

        if (parts.length === 1 || (parts.length > 1 && currentInput.endsWith(' '))) { /* Command completion */
          const suggestions = Object.keys(AppManager.cliCommands).filter(cmd => cmd.startsWith(cmdPart));
          if (suggestions.length === 1) Terminal.inputElement.value = suggestions[0] + ' ';
          else if (suggestions.length > 1) Terminal.print(suggestions.join('  '));
        } else { /* Argument (file/dir) completion - now uses backend */
          const baseCompletionPath = argPart.startsWith('/') ? argPart : OBPI.currentPath + argPart;
          let searchDir = baseCompletionPath;
          let prefix = argPart.split('/').pop();
          if (!currentInput.endsWith('/')) searchDir = baseCompletionPath.substring(0, baseCompletionPath.lastIndexOf('/') + 1);
          else prefix = '';

          try {
            const response = await window.pywebview.api.list_directory_backend(searchDir || OBPI.currentPath);
            if (response.error) {
              OBPI.kernel.log(`Tab completion error: ${response.error}`, 'error');
              return;
            }
            if (response.contents && response.contents.length > 0) {
              const items = response.contents.filter(item => item.name.startsWith(prefix));
              if (items.length === 1) {
                const completion = argPart.substring(0, argPart.lastIndexOf('/') +1) + items[0].name + (items[0].type === 'dir' ? '/' : ' ');
                Terminal.inputElement.value = cmdPart + ' ' + completion;
              } else if (items.length > 1) {
                Terminal.print(items.map(item => `${item.name}${item.type === 'dir' ? '/' : ''}`).join('  '));
              }
            }
          } catch (e) {
            OBPI.kernel.log(`Tab completion backend call error: ${e.message}`, 'error');
          }
        }
      }
    },
    clear: () => { if(Terminal.outputElement) Terminal.outputElement.innerHTML = ''; }
  };

  // --- PEPx Storage System (Client-side, metadata persisted to backend, raw data in VFS) ---
  // Refactored to remove client-side canvas for data storage.
  class PEPxStorage {
    constructor() {
      this.metadataStore = new PEPxMetadataStore('pepx_metadata_v1.0'); // Updated key for its metadata
      OBPI.kernel.log(`PEPxStorage: Instantiated. Raw data stored in VFS.`, 'info');
    }

    // No initializeCanvases needed anymore for data storage, only metadata load
    async initialize() {
      await this.metadataStore.loadFromBackend();
      OBPI.kernel.log(`PEPxStorage: Initialized and metadata loaded.`, 'success');
    }

    // Capacity is now conceptual, based on VFS space
    calculateCapacity() {
      // In a real system, this would query VFS_ROOT disk space
      return 1024 * 1024 * 1024 * 2; // 2GB conceptual capacity for PEPx
    }

    async storeFile(file, path) {
      OBPI.kernel.log(`PEPx: Storing file "${file.name}" to path "${path}"`, 'info');
      try {
        const arrayBuffer = await this.readFileAsArrayBuffer(file);
        const dataToStore = new Uint8Array(arrayBuffer);
        const rawData_base64 = btoa(String.fromCharCode.apply(null, dataToStore)); // Convert Uint8Array to binary string, then base64

        const fileId = this.generateUniqueId();

        // Store raw data in backend VFS
        const storeRawResponse = await window.pywebview.api.pepx_store_raw_data_backend(fileId, rawData_base64);
        if (storeRawResponse.error) {
          throw new Error(`Backend raw data storage failed: ${storeRawResponse.error}`);
        }

        // Store metadata in backend SQLite
        this.metadataStore.addFile({
          id: fileId, name: file.name, path: path, size: file.size,
          storedByteLength: dataToStore.byteLength,
          type: file.type,
          created: new Date().toISOString(), modified: new Date().toISOString()
        });
        OBPI.kernel.log(`PEPx: File "${file.name}" stored successfully. ID: ${fileId}`, 'success');
        return fileId;
      } catch (error) { OBPI.kernel.log(`PEPx: Failed to store file "${file.name}": ${error.message}`, 'error'); throw error; }
    }

    async retrieveFile(fileId) {
      OBPI.kernel.log(`PEPx: Retrieving file ID "${fileId}"`, 'info');
      const metadata = this.metadataStore.getFile(fileId);
      if (!metadata) throw new Error(`PEPx: File metadata not found for ID: ${fileId}`);

      // Retrieve raw data from backend VFS
      const getRawResponse = await window.pywebview.api.pepx_get_raw_data_backend(fileId);
      if (getRawResponse.error) {
        throw new Error(`Backend raw data retrieval failed: ${getRawResponse.error}`);
      }
      const rawData_base64 = getRawResponse.rawData;
      const binaryString = atob(rawData_base64);
      const dataBytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        dataBytes[i] = binaryString.charCodeAt(i);
      }

      OBPI.kernel.log(`PEPx: File "${metadata.name}" retrieved successfully.`, 'success');
      return new Blob([dataBytes.buffer], { type: metadata.type });
    }

    // findFreeSpace and pixel-level encode/decode are no longer relevant for storage logic
    // but kept as conceptual placeholders if needed for other pixel-based operations.
    findFreeSpace(bytesNeeded) { return { plane: 0, startX: 0, startY: 0, pixelCount: bytesNeeded }; }
    encodeDataToPixels(dataBytes, allocation) { OBPI.kernel.log("PEPx: Conceptual pixel encoding (data stored as raw file).", "info"); }
    decodeDataFromPixels(allocation, storedByteLength) { OBPI.kernel.log("PEPx: Conceptual pixel decoding (data retrieved as raw file).", "info"); return new Uint8Array(storedByteLength); }

    readFileAsArrayBuffer(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = reject; reader.readAsArrayBuffer(file); }); }
    generateUniqueId() { return 'pepx-' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5); }
  }

  class PEPxMetadataStore {
    constructor(storageKey = 'pepx_metadata_default') {
      this.storageKey = storageKey;
      this.files = {};
    }

    async loadFromBackend() {
      try {
        const response = await window.pywebview.api.pepx_get_metadata_backend();
        if (response && response.files) {
          this.files = response.files;
          OBPI.kernel.log("PEPx metadata loaded from backend.", "success");
        } else if (response.error) {
          OBPI.kernel.log(`Error loading PEPx metadata from backend: ${response.error}`, "error");
        }
      } catch (e) {
        OBPI.kernel.log(`Failed to communicate with backend for PEPx metadata: ${e.message}`, "error");
      }
    }

    async saveToBackend() {
      try {
        const response = await window.pywebview.api.pepx_sync_metadata_backend(this.files);
        if (response && response.status === 'success') {
          OBPI.kernel.log("PEPx metadata synchronized to backend.", "success");
        } else if (response.error) {
          OBPI.kernel.log(`Error synchronizing PEPx metadata to backend: ${response.error}`, "error");
        }
      } catch (e) {
        OBPI.kernel.log(`Failed to communicate with backend for PEPx sync: ${e.message}`, "error");
      }
    }

    addFile(metadata) {
      this.files[metadata.id] = metadata;
      this.saveToBackend();
    }
    getFile(fileId) { return this.files[fileId]; }
    deleteFile(fileId) {
      delete this.files[fileId];
      this.saveToBackend();
    }
    listFiles(path = '/') {
      if (!path.startsWith('/')) path = '/' + path;
      if (path !== '/' && path.endsWith('/')) path = path.slice(0, -1);

      return Object.values(this.files).filter(file => {
        // For root, path should be exactly "/" or like "/filename.txt" (no further slashes)
        if (path === '/') {
          return file.path === '/' || (file.path.startsWith('/') && file.path.substring(1).indexOf('/') === -1);
        } else {
          // For subdirs, path should be exactly currentPath or currentPath + "/filename.txt"
          const expectedPrefix = path.endsWith('/') ? path : path + '/';
          return file.path === path || (file.path.startsWith(expectedPrefix) && file.path.substring(expectedPrefix.length).indexOf('/') === -1);
        }
      });
    }
  }

  class PEPxFileManager {
    constructor(storageInstance) {
      this.storage = storageInstance;
      this.currentPath = '/'; // PEPx internal path
      this.uiContainer = null;
      this.fileListElement = null;
      this.pathDisplayElement = null;
      this.statusElement = null;
    }

    initUI(containerElement) {
      this.uiContainer = containerElement;
      this.uiContainer.innerHTML = `
                <div class="pepx-file-manager">
                    <div class="pepx-toolbar">
                        <button id="pepx-back-btn">⬅ Back</button>
                        <button id="pepx-home-btn">🏠 Home</button>
                        <input type="text" id="pepx-path-display" value="${this.currentPath}" readonly>
                        <button id="pepx-upload-btn" class="ml-auto">⬆️ Upload</button>
                        <button id="pepx-new-folder-btn">➕ New Folder</button>
                    </div>
                    <div class="pepx-file-list" id="pepx-file-list-area"></div>
                    <div class="pepx-status-bar">
                        <span id="pepx-status-text">Ready</span>
                        <span id="pepx-item-count">0 items</span>
                    </div>
                </div>
            `;
      this.fileListElement = this.uiContainer.querySelector('#pepx-file-list-area');
      this.pathDisplayElement = this.uiContainer.querySelector('#pepx-path-display');
      this.statusElement = this.uiContainer.querySelector('#pepx-status-text');

      this.uiContainer.querySelector('#pepx-back-btn').onclick = () => this.navigateUp();
      this.uiContainer.querySelector('#pepx-home-btn').onclick = () => this.navigate('/');
      this.uiContainer.querySelector('#pepx-upload-btn').onclick = () => this.showUploadDialog();
      this.uiContainer.querySelector('#pepx-new-folder-btn').onclick = () => this.createNewFolder();

      this.fileListElement.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const itemElement = e.target.closest('.pepx-item');
        if (itemElement && itemElement.dataset.id) {
          const fileId = itemElement.dataset.id;
          const file = this.storage.metadataStore.getFile(fileId);
          if (file) this.showFileContextMenu(file, e);
        } else {
          this.showPathContextMenu(e);
        }
      });

      this.refreshFileList();
    }

    async refreshFileList() {
      if (!this.fileListElement || !this.storage || !this.storage.metadataStore) {
        OBPI.kernel.log("PEPxFileManager: UI or storage not ready for refresh.", "warn");
        return;
      }
      // Ensure metadata is loaded from backend before listing
      await this.storage.metadataStore.loadFromBackend();

      const filesInCurrentPath = this.storage.metadataStore.listFiles(this.currentPath);

      this.fileListElement.innerHTML = '';
      filesInCurrentPath.sort((a,b) => {
        if (a.type === 'folder' && b.type !== 'folder') return -1;
        if (a.type !== 'folder' && b.type === 'folder') return 1;
        return a.name.localeCompare(b.name);
      });

      filesInCurrentPath.forEach(file => {
        const element = document.createElement('div');
        element.className = 'pepx-item';
        element.dataset.id = file.id;
        element.title = `${file.name}\nType: ${file.type}\nSize: ${this.formatFileSize(file.size)}\nModified: ${new Date(file.modified).toLocaleString()}`;

        let icon = '📄';
        if (file.type === 'folder') icon = '📁';
        else if (file.type.startsWith('image/')) icon = '🖼️';
        else if (file.type.startsWith('video/')) icon = '🎬';
        else if (file.type.startsWith('audio/')) icon = '🎵';
        else if (file.type.startsWith('application/pdf')) icon = '📜';
        else if (file.type.includes('zip') || file.type.includes('archive')) icon = '📦';

        element.innerHTML = `
                    <div class="pepx-icon">${icon}</div>
                    <div class="pepx-name">${file.name}</div>
                    ${file.type !== 'folder' ? `<div class="pepx-size">${this.formatFileSize(file.size)}</div>` : ''}
                `;
        element.ondblclick = () => {
          if (file.type === 'folder') this.navigate(file.path); // Navigate to the folder's own path
          else this.openFile(file.id);
        };
        this.fileListElement.appendChild(element);
      });
      this.pathDisplayElement.value = this.currentPath;
      this.uiContainer.querySelector('#pepx-item-count').textContent = `${filesInCurrentPath.length} items`;
    }

    navigate(newPath) {
      if (!newPath.startsWith('/')) newPath = '/' + newPath;
      if (newPath !== '/' && newPath.endsWith('/')) newPath = newPath.slice(0, -1);

      this.currentPath = newPath;
      this.refreshFileList();
    }

    navigateUp() {
      if (this.currentPath === '/') return;
      const parts = this.currentPath.split('/').filter(Boolean);
      parts.pop();
      this.navigate(parts.length > 0 ? '/' + parts.join('/') : '/');
    }

    showUploadDialog() {
      const input = document.createElement('input');
      input.type = 'file'; input.multiple = true;
      input.onchange = async () => {
        const files = input.files;
        if (!files || files.length === 0) return;
        this.statusElement.textContent = `Uploading ${files.length} file(s)...`;
        Modal.show("Uploading Files", `Preparing to upload ${files.length} file(s) to PEPx storage at ${this.currentPath}. This might take a while for large files.`, [{text: "Close"}]);

        for (let i = 0; i < files.length; i++) {
          try {
            this.statusElement.textContent = `Uploading ${files[i].name}... (${i+1}/${files.length})`;
            await this.storage.storeFile(files[i], this.currentPath);
          } catch (error) { OBPI.kernel.log(`PEPx: Failed to upload ${files[i].name}: ${error.message}`, 'error'); Modal.show("Upload Error", `Failed to upload ${files[i].name}: ${error.message}`);}
        }
        this.statusElement.textContent = 'Upload complete.';
        Modal.hide();
        this.refreshFileList();
      };
      input.click();
    }

    async openFile(fileId) {
      this.statusElement.textContent = 'Loading file...';
      try {
        const metadata = this.storage.metadataStore.getFile(fileId);
        if (!metadata) throw new Error(`File not found: ${fileId}`);
        const blob = await this.storage.retrieveFile(fileId);
        const url = URL.createObjectURL(blob);

        let modalContent;
        if (metadata.type.startsWith('image/')) {
          modalContent = `<img src="${url}" alt="${metadata.name}" class="pepx-modal-body img">`;
        } else if (metadata.type.startsWith('text/') || metadata.type === 'application/json' || metadata.type === 'application/xml') {
          const text = await blob.text();
          modalContent = `<pre class="pepx-modal-body pre">${text.replace(/</g, "&lt;")}</pre>`;
        } else {
          Modal.confirm("Download File", `Preview not available for "${metadata.name}" (${metadata.type}). Download instead?`, (doDownload) => {
            if (doDownload) this.downloadFile(url, metadata.name); else URL.revokeObjectURL(url);
          });
          this.statusElement.textContent = 'Ready';
          return;
        }
        Modal.show(metadata.name, modalContent, [{text: 'Close', handler: () => URL.revokeObjectURL(url)}]);
        this.statusElement.textContent = 'Ready';
      } catch (error) { OBPI.kernel.log(`PEPx: Failed to open file ${fileId}: ${error.message}`, 'error'); this.statusElement.textContent = 'Error opening file.'; Modal.show("Error", `Could not open file: ${error.message}`);}
    }

    downloadFile(url, name) { const a = document.createElement('a'); a.href = url; a.download = name; a.style.display = 'none'; document.body.appendChild(a); a.click(); document.body.removeChild(a); setTimeout(() => URL.revokeObjectURL(url), 100); }

    createNewFolder() {
      Modal.prompt('Create New Folder', 'Enter folder name:', 'New Folder', (folderName) => {
        if (!folderName) return;
        const newFolderPath = this.currentPath === '/' ? `/${folderName}` : `${this.currentPath}/${folderName}`;

        const existing = Object.values(this.storage.metadataStore.files).find(f => f.path === newFolderPath && f.type === 'folder');
        if (existing) { Modal.show("Error", `A folder named "${folderName}" already exists here.`); return; }

        const folderId = this.storage.generateUniqueId();
        this.storage.metadataStore.addFile({
          id: folderId, name: folderName,
          path: newFolderPath,
          parentPath: this.currentPath,
          type: 'folder', size: 0,
          created: new Date().toISOString(), modified: new Date().toISOString()
        });
        this.refreshFileList();
        this.statusElement.textContent = `Folder '${folderName}' created.`;
      });
    }

    showPathContextMenu(event) {
      const menuItems = [
        { label: 'New Folder...', action: 'new-folder-here', icon: '📁' },
        { label: 'Upload Files...', action: 'upload-here', icon: '⬆️' },
        { label: 'Refresh', action: 'refresh-current', icon: '🔄' }
      ];
      OBPI.contextMenuElement.innerHTML = '';
      menuItems.forEach(item => {
        const menuItemEl = document.createElement('div');
        menuItemEl.className = 'context-menu-item';
        menuItemEl.innerHTML = `<span class="mr-2">${item.icon}</span> ${item.label}`;
        menuItemEl.onclick = () => {
          OBPI.contextMenuElement.classList.add('hidden');
          if (item.action === 'new-folder-here') this.createNewFolder();
          else if (item.action === 'upload-here') this.showUploadDialog();
          else if (item.action === 'refresh-current') this.refreshFileList();
        };
        OBPI.contextMenuElement.appendChild(menuItemEl);
      });
      OBPI.contextMenuElement.style.top = `${event.clientY}px`;
      OBPI.contextMenuElement.style.left = `${event.clientX}px`;
      OBPI.contextMenuElement.classList.remove('hidden');
    }

    showFileContextMenu(file, event) {
      const menuItems = [
        { label: 'Open', action: 'open', icon: '📂' },
        { label: 'Download', action: 'download', icon: '💾' },
        { label: 'Rename...', action: 'rename', icon: '✏️' },
        { label: 'Delete', action: 'delete', icon: '🗑️' },
        { label: 'Properties', action: 'properties', icon: 'ℹ️'}
      ];
      OBPI.contextMenuElement.innerHTML = '';
      menuItems.forEach(item => {
        const menuItemEl = document.createElement('div');
        menuItemEl.className = 'context-menu-item';
        menuItemEl.innerHTML = `<span class="mr-2">${item.icon}</span> ${item.label}`;
        menuItemEl.onclick = () => {
          OBPI.contextMenuElement.classList.add('hidden');
          if (item.action === 'open') this.openFile(file.id);
          else if (item.action === 'download') this.downloadFileById(file.id);
          else if (item.action === 'rename') this.renameFile(file.id);
          else if (item.action === 'delete') this.deleteFile(file.id);
          else if (item.action === 'properties') this.showFileProperties(file.id);
        };
        OBPI.contextMenuElement.appendChild(menuItemEl);
      });
      OBPI.contextMenuElement.style.top = `${event.clientY}px`;
      OBPI.contextMenuElement.style.left = `${event.clientX}px`;
      OBPI.contextMenuElement.classList.remove('hidden');
    }

    async downloadFileById(fileId) {
      this.statusElement.textContent = `Preparing download for ${fileId}...`;
      try {
        const metadata = this.storage.metadataStore.getFile(fileId);
        if (!metadata) throw new Error(`File not found: ${fileId}`);
        const blob = await this.storage.retrieveFile(fileId);
        const url = URL.createObjectURL(blob);
        this.downloadFile(url, metadata.name);
        this.statusElement.textContent = 'Download started.';
      } catch (error) { OBPI.kernel.log(`PEPx: Failed to download file ${fileId}: ${error.message}`, 'error'); this.statusElement.textContent = 'Error downloading file.'; Modal.show("Error", `Could not download file: ${error.message}`);}
    }
    renameFile(fileId) {
      const metadata = this.storage.metadataStore.getFile(fileId); if (!metadata) return;
      Modal.prompt('Rename File/Folder', 'Enter new name:', metadata.name, async (newName) => { // Made async
        if (newName && newName !== metadata.name) {
          // Check for existing name at the same level
          const existing = Object.values(this.storage.metadataStore.files).find(f =>
            f.parentPath === metadata.parentPath && f.name === newName && f.id !== fileId
          );
          if (existing) {
            Modal.show("Error", `An item named "${newName}" already exists here.`);
            return;
          }

          metadata.name = newName;
          metadata.modified = new Date().toISOString();
          // If it's a folder, its path also needs to change in metadata
          if (metadata.type === 'folder') {
            const oldPath = metadata.path;
            const parentPath = oldPath.substring(0, oldPath.lastIndexOf('/'));
            metadata.path = parentPath === '' ? `/${newName}` : `${parentPath}/${newName}`;
            // Recursively update paths of children
            for (const childId in this.storage.metadataStore.files) {
              const child = this.storage.metadataStore.files[childId];
              if (child.path.startsWith(oldPath + '/')) {
                child.path = metadata.path + child.path.substring(oldPath.length);
                child.parentPath = metadata.path; // Update parentPath for direct children
                child.modified = new Date().toISOString();
              }
            }
          }
          await this.storage.metadataStore.saveToBackend(); // Save to backend
          this.refreshFileList();
          this.statusElement.textContent = `Renamed to '${newName}'.`;
        }
      });
    }
    deleteFile(fileId) {
      const metadata = this.storage.metadataStore.getFile(fileId); if (!metadata) return;
      Modal.confirm('Delete Item', `Are you sure you want to delete "${metadata.name}"? ${metadata.type === 'folder' ? 'This will also delete all its contents.' : ''}`, async (confirmed) => { // Made async
        if (confirmed) {
          if (metadata.type === 'folder') {
            const childrenToDelete = Object.values(this.storage.metadataStore.files).filter(f => f.path.startsWith(metadata.path + '/') || f.path === metadata.path);
            childrenToDelete.forEach(child => this.storage.metadataStore.deleteFile(child.id));
          }
          this.storage.metadataStore.deleteFile(fileId);
          await this.storage.metadataStore.saveToBackend(); // Save to backend
          this.refreshFileList(); this.statusElement.textContent = `"${metadata.name}" deleted.`;
        }
      });
    }
    showFileProperties(fileId) {
      const metadata = this.storage.metadataStore.getFile(fileId);
      if (!metadata) { Modal.show("Error", "File properties not found."); return; }
      const content = `
                <p><strong>Name:</strong> ${metadata.name}</p>
                <p><strong>Type:</strong> ${metadata.type}</p>
                <p><strong>Size:</strong> ${this.formatFileSize(metadata.size)} (${metadata.size} bytes)</p>
                <p><strong>Stored Size (PEPx):</strong> ${this.formatFileSize(metadata.storedByteLength || metadata.size)}</p>
                <p><strong>Path:</strong> ${metadata.path}</p>
                <p><strong>Parent Path:</strong> ${metadata.parentPath || '/'}</p>
                <p><strong>ID:</strong> ${metadata.id}</p>
                <p><strong>Created:</strong> ${new Date(metadata.created).toLocaleString()}</p>
                <p><strong>Modified:</strong> ${new Date(metadata.modified).toLocaleString()}</p>
                ${metadata.allocation ? `
                <p><strong>Allocation:</strong> Plane ${metadata.allocation.plane}, Start (${metadata.allocation.startX}, ${metadata.allocation.startY}), Pixels ${metadata.allocation.pixelCount}</p>
                ` : ''}
            `;
      Modal.show(`Properties: ${metadata.name}`, content);
    }
    formatFileSize(bytes) { if (bytes === undefined || bytes === null || isNaN(bytes)) return 'N/A'; if (bytes === 0 && typeof bytes === 'number') return '0 B'; const units = ['B', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(1024)); return (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + units[i]; }
  }

  // --- Application Manager ---
  const AppManager = {
    installedApps: {
      'web_view': { name: 'Web View', launch: () => AppManager.launch('web-view', 'Encapsulated Web View', AppManager.apps.encapsulatedBrowser.init(), {width: '1000px', height: '700px'}), icon: '🌐' },
      'dechex_ide': { name: 'DecHex IDE', launch: () => AppManager.launch('dechex-ide', 'DecHex IDE', AppManager.apps.dechexIDE.init()), icon: '⚙️' },
      'ai_assistant': { name: 'AI Assistant', launch: () => AppManager.launch('ai-assistant', 'AI Assistant', AppManager.apps.aiAssistant.init(), {width: '700px', height: '600px'}), icon: '🤖' },
      'disk_manager': { name: 'Disk Manager (VFS)', launch: () => AppManager.launch('disk-manager', 'VFS Disk Manager', AppManager.apps.diskManager.init()), icon: '💾' },
      'pepx_explorer': { name: 'PEPx Explorer', launch: () => AppManager.launch('pepx-explorer', 'PEPx Pixel Storage Explorer', AppManager.apps.pepxExplorer.init(), {width:'800px', height:'650px'}), icon: '🖼️' },
      'ncurses_demo': { name: 'Ncurses Demo', launch: () => AppManager.launch('ncurses-app', 'Ncurses Demo App', AppManager.apps.ncursesApp.init(), {width:'500px', height:'350px'}), icon: '⣀' },
      'python_runner': { name: 'Python Runner', launch: () => AppManager.launch('python-runner', 'Python Runner', AppManager.apps.pythonRunner.init(), {width:'700px', height:'550px'}), icon: '🐍' },
      'py_ide': { name: 'Python IDE', launch: () => AppManager.launch('py-ide', 'Python IDE', AppManager.apps.pyIDE.init(), {width:'800px', height:'600px'}), icon: '📝' },
      'network_manager': { name: 'Network Manager', launch: () => AppManager.launch('network-manager', 'Network Manager', AppManager.apps.networkManager.init()), icon: '📶' },
      'bluetooth_manager': { name: 'Bluetooth Manager', launch: () => AppManager.launch('bluetooth-manager', 'Bluetooth Manager', AppManager.apps.bluetoothManager.init()), icon: '📱' },
      'peripheral_manager': { name: 'Peripheral Manager', launch: () => AppManager.launch('peripheral-manager', 'Peripheral Manager', AppManager.apps.peripheralManager.init(), {width:'700px', height:'500px'}), icon: '🔌' }, // New App
      'theme_settings': { name: 'Theme Settings', launch: () => AppManager.apps.themeSettings.launch(), icon: '🎨' },
      'wasm_core_test': { name: 'WASM Core Test', launch: () => AppManager.apps.wasmCoreTest.run(), icon: '🧩' },
      'xml_parser_test': { name: 'XML Parser Test', launch: () => AppManager.apps.xmlParserTest.run(), icon: '📰' },
      'ejs_sim_test': { name: 'EJS Sim Test', launch: () => { const content = EJSSimulator.renderExample(); WindowManager.create('ejs-test-window', 'EJS Simulator Output', content, {width: '500px', height: '300px'}); }, icon: '📄' }
    },
    launch: (id, title, content, options = {}) => WindowManager.create(id, title, content, options),
    executeCommand: async (commandStr) => {
      let originalCommandStr = commandStr;
      commandStr = commandStr.replace(/\$([A-Za-z_][A-Za-z0-9_]*)/g, (match, varName) => OBPI.envVars[varName] || '');
      const parts = commandStr.split(/\s+/);
      let command = parts[0].toLowerCase();
      const args = parts.slice(1);
      if (OBPI.aliases[command]) {
        const aliasCmdStr = OBPI.aliases[command] + (args.length > 0 ? ' ' + args.join(' ') : '');
        Terminal.print(`Alias: ${command} -> ${aliasCmdStr}`, false, 'info');
        await AppManager.executeCommand(aliasCmdStr);
        return;
      }
      const cmdFunc = AppManager.cliCommands[command];
      if (cmdFunc) {
        try {
          await cmdFunc(args);
        } catch (e) {
          Terminal.print(`Error executing '${command}': ${e.message}`, false, 'error');
          OBPI.kernel.log(`CLI Error: ${e.stack}`, 'error');
        }
      } else { Terminal.print(`Command not found: ${command}. Type 'help'.`, false, 'error'); }
      Terminal.updatePrompt();
    },
    cliCommands: {
      help: (args) => { // Enhanced help command
        if (args.length === 0) {
          Terminal.print("OBPI CLI v1.0 - Available Commands:");
          Object.keys(AppManager.cliCommands).sort().forEach(cmd => { Terminal.print(`  ${cmd.padEnd(18)} - ${AppManager.cliCommandDescriptions[cmd] || 'No description.'}`); });
          Terminal.print("\nType 'help <command>' or 'man <command>' for more details.");
        } else {
          const command = args[0].toLowerCase();
          const helpText = AppManager.cliHelpPages[command];
          if (helpText) {
            Terminal.print(`Help for '${command}':\n${helpText}`);
          } else {
            Terminal.print(`No help entry found for '${command}'.`);
          }
        }
      },
      man: (args) => { // New man command
        if (args.length === 0) { Terminal.print("man: missing operand. Usage: man <command>", false, 'error'); return; }
        const command = args[0].toLowerCase();
        const manPage = AppManager.cliManPages[command];
        if (manPage) {
          Terminal.print(`MANUAL PAGE for '${command}':\n${manPage}`);
        } else {
          Terminal.print(`No manual page found for '${command}'.`);
        }
      },
      pkg_build: async (args) => { // New conceptual pkg_build command
        if (args.length === 0) { Terminal.print("pkg_build: missing operand. Usage: pkg_build <package_name>", false, 'error'); return; }
        const pkgName = args[0];
        Terminal.print(`Simulating package build for '${pkgName}'...`, false, 'info');
        Terminal.print(`Creating dummy executable in /bin/${pkgName}...`, false, 'info');
        // Simulate creating a simple executable script
        const response = await window.pywebview.api.write_file_backend(`/bin/${pkgName}`, `#!/bin/obsh\necho "Hello from ${pkgName} package!"\n`);
        if (response.error) {
          Terminal.print(`pkg_build: Failed to create package file: ${response.error}`, false, 'error');
        } else {
          Terminal.print(`Package '${pkgName}' built and placed in /bin/. Try 'exec /bin/${pkgName}'`, false, 'success');
        }
      },
      process_list: () => { // New process_list command
        Terminal.print("Active Processes (Windows):");
        if (Object.keys(OBPI.windows).length === 0) {
          Terminal.print("  No windows currently open.");
          return;
        }
        for (const id in OBPI.windows) {
          const win = OBPI.windows[id];
          Terminal.print(`  PID: ${win.element.id.split('-')[1].padEnd(10)} Name: ${win.title.padEnd(25)} State: ${win.minimized ? 'MINIMIZED' : 'RUNNING'}`);
        }
      },
      resource_monitor: async () => { // Now uses backend for real data
        Terminal.print("Fetching System Resource Information...", false, 'info');
        try {
          const response = await window.pywebview.api.get_system_info_backend();
          if (response.error) {
            Terminal.print(`Resource monitor error: ${response.error}`, false, 'error');
            return;
          }
          Terminal.print("System Resource Usage:");
          Terminal.print(`  CPU Cores (Logical/Physical): ${response.total_cpu_cores}/${response.physical_cpu_cores}`);
          Terminal.print(`  CPU Usage (Simulated): ${(Math.random() * 100).toFixed(2)}%`); // Still simulated for dynamic feel
          Terminal.print(`  RAM Total: ${response.total_memory_gb} GB`);
          Terminal.print(`  RAM Available: ${response.available_memory_gb} GB`);
          Terminal.print(`  RAM Usage (Simulated): ${(Math.random() * 100).toFixed(2)}%`); // Still simulated for dynamic feel
        } catch (e) {
          Terminal.print(`resource_monitor error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`resource_monitor backend call error: ${e.stack}`, 'error');
        }
      },
      date: () => Terminal.print(new Date().toLocaleString()), clear: Terminal.clear, exit: () => WindowManager.close('terminal'), echo: (args) => Terminal.print(args.join(' ')),
      pwd: () => Terminal.print(OBPI.currentPath),

      // --- Backend-driven File System Commands ---
      ls: async (args) => {
        const pathArg = args[0] || OBPI.currentPath;
        try {
          const response = await window.pywebview.api.list_directory_backend(pathArg);
          if (response.error) {
            Terminal.print(`ls: ${response.error}`, false, 'error');
            return;
          }
          if (response.contents && response.contents.length > 0) {
            const items = response.contents.map(item => `${item.name}${item.type === 'dir' ? '/' : ''}`);
            Terminal.print(items.join('  '));
          } else {
            Terminal.print('(empty directory)');
          }
        } catch (e) {
          Terminal.print(`ls error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`ls backend call error: ${e.stack}`, 'error');
        }
      },
      cd: async (args) => {
        if (!args[0]) {
          OBPI.currentPath = '/'; // Default to root
          Terminal.updatePrompt();
          return;
        }
        let targetPath = args[0];
        // Normalize path: if relative, prepend currentPath
        if (!targetPath.startsWith('/')) {
          targetPath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + targetPath;
        }
        // Handle '..' and '.'
        targetPath = targetPath.split('/').reduce((acc, part) => {
          if (part === '..') acc.pop();
          else if (part !== '.' && part !== '') acc.push(part);
          return acc;
        }, []).join('/');
        targetPath = '/' + targetPath; // Ensure leading slash

        try {
          const response = await window.pywebview.api.list_directory_backend(targetPath);
          if (response.error) {
            Terminal.print(`cd: ${response.error}`, false, 'error');
            return;
          }
          // If it's a directory (no error, and it has contents or is empty)
          if (response.contents !== undefined) {
            OBPI.currentPath = targetPath.endsWith('/') || targetPath === '/' ? targetPath : targetPath + '/';
            Terminal.updatePrompt();
          } else {
            Terminal.print(`cd: '${args[0]}': Not a directory`, false, 'error');
          }
        } catch (e) {
          Terminal.print(`cd error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`cd backend call error: ${e.stack}`, 'error');
        }
      },
      cat: async (args) => {
        if (!args[0]) { Terminal.print("cat: missing file operand", false, 'error'); return; }
        let filePath = args[0];
        if (!filePath.startsWith('/')) {
          filePath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + filePath;
        }
        try {
          const response = await window.pywebview.api.get_file_content_backend(filePath);
          if (response.error) {
            Terminal.print(`cat: ${response.error}`, false, 'error');
          } else {
            Terminal.print(response.content || '(empty file)');
          }
        } catch (e) {
          Terminal.print(`cat error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`cat backend call error: ${e.stack}`, 'error');
        }
      },
      mkdir: async (args) => {
        if (!args[0]) { Terminal.print("mkdir: missing operand", false, 'error'); return; }
        const dirName = args[0];
        if (dirName.includes('/')) { Terminal.print("mkdir: directory name cannot contain '/'", false, 'error'); return; }
        const newDirPath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + dirName;
        try {
          const response = await window.pywebview.api.create_directory_backend(newDirPath);
          if (response.error) {
            Terminal.print(`mkdir: ${response.error}`, false, 'error');
          } else {
            Terminal.print(`Directory created: ${newDirPath}`, false, 'success');
          }
        } catch (e) {
          Terminal.print(`mkdir error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`mkdir backend call error: ${e.stack}`, 'error');
        }
      },
      write: async (args) => {
        if (args.length < 2) { Terminal.print("write: usage: write <filename> \"<text>\"", false, 'error'); return; }
        const fileName = args[0];
        const content = args.slice(1).join(" ").replace(/^"|"$/g, '');
        let filePath = fileName;
        if (!filePath.startsWith('/')) {
          filePath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + filePath;
        }
        try {
          const response = await window.pywebview.api.write_file_backend(filePath, content);
          if (response.error) {
            Terminal.print(`write: ${response.error}`, false, 'error');
          } else {
            Terminal.print(`Content written to ${filePath}`, false, 'success');
          }
        } catch (e) {
          Terminal.print(`write error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`write backend call error: ${e.stack}`, 'error');
        }
      },
      rm: async (args) => {
        if (!args[0]) { Terminal.print("rm: missing operand", false, 'error'); return; }
        let targetPath = args[0];
        let recursive = false;
        if (args[0] === '-r' || args[0] === '-rf') {
          recursive = true;
          targetPath = args[1];
          if (!targetPath) { Terminal.print("rm: missing operand after -r", false, 'error'); return; }
        }

        if (!targetPath.startsWith('/')) {
          targetPath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + targetPath;
        }
        try {
          const response = await window.pywebview.api.delete_path_backend(targetPath, recursive);
          if (response.error) {
            Terminal.print(`rm: ${response.error}`, false, 'error');
          } else {
            Terminal.print(`Deleted: ${targetPath}`, false, 'success');
          }
        } catch (e) {
          Terminal.print(`rm error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`rm backend call error: ${e.stack}`, 'error');
        }
      },
      mv: async (args) => {
        if (args.length < 2) { Terminal.print("mv: usage: mv <source> <destination>", false, 'error'); return; }
        let sourcePath = args[0];
        let destPath = args[1];

        if (!sourcePath.startsWith('/')) sourcePath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + sourcePath;
        if (!destPath.startsWith('/')) destPath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + destPath;

        try {
          const response = await window.pywebview.api.move_path_backend(sourcePath, destPath);
          if (response.error) {
            Terminal.print(`mv: ${response.error}`, false, 'error');
          } else {
            Terminal.print(`Moved '${sourcePath}' to '${destPath}'`, false, 'success');
          }
        } catch (e) {
          Terminal.print(`mv error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`mv backend call error: ${e.stack}`, 'error');
        }
      },
      cp: async (args) => {
        if (args.length < 2) { Terminal.print("cp: usage: cp <source> <destination>", false, 'error'); return; }
        let sourcePath = args[0];
        let destPath = args[1];

        if (!sourcePath.startsWith('/')) sourcePath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + sourcePath;
        if (!destPath.startsWith('/')) destPath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + destPath;

        try {
          const response = await window.pywebview.api.copy_path_backend(sourcePath, destPath);
          if (response.error) {
            Terminal.print(`cp: ${response.error}`, false, 'error');
          } else {
            Terminal.print(`Copied '${sourcePath}' to '${destPath}'`, false, 'success');
          }
        } catch (e) {
          Terminal.print(`cp error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`cp backend call error: ${e.stack}`, 'error');
        }
      },
      // --- End Backend-driven File System Commands ---

      run: (args) => {
        if (!args[0]) { Terminal.print("run: missing app ID", false, 'error'); return; }
        const appId = args[0].toLowerCase();
        if (AppManager.installedApps[appId]) { AppManager.installedApps[appId].launch(); }
        else { Terminal.print(`run: app '${appId}' not found. Available: ${Object.keys(AppManager.installedApps).join(', ')}`, false, 'error'); }
      },
      install: (args) => {
        if (!args[0]) { Terminal.print("install: missing app_url or app_id", false, 'error'); return; }
        const appIdentifier = args[0];
        if (AppManager.installedApps[appIdentifier]) { Terminal.print(`App '${appIdentifier}' is already conceptually available. Use 'run ${appIdentifier}'.`); }
        else { Terminal.print(`Simulating installation of '${appIdentifier}'... This is a conceptual command.`, false, 'info'); Terminal.print(`For actual new apps, add them to AppManager.installedApps in the source code.`); }
      },
      curl: async (args) => {
        if (!args[0]) { Terminal.print("curl: no URL specified", false, 'error'); return; }
        const url = args[0];
        Terminal.print(`Fetching ${url}...`, false, 'info');
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          const text = await response.text();
          Terminal.print(`Response from ${url}:\n--------------------\n${text.substring(0, 1000)}${text.length > 1000 ? '...' : ''}`);
        } catch (e) { Terminal.print(`curl error: ${e.message}`, false, 'error'); }
      },
      wget: async (args) => {
        if (!args[0]) { Terminal.print("wget: no URL specified", false, 'error'); return; }
        const url = args[0];
        let outputFilename = args.find(arg => arg.startsWith('-O='))?.split('=')[1] || url.split('/').pop() || 'downloaded_file';
        if (!outputFilename) outputFilename = 'index.html';
        Terminal.print(`Downloading ${url} to ${outputFilename}...`, false, 'info');
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          const text = await response.text();
          // Now using backend to write the file
          const fullPath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + outputFilename;
          const writeResponse = await window.pywebview.api.write_file_backend(fullPath, text); // Write full content
          if (writeResponse.error) {
            Terminal.print(`wget: Could not save to VFS: ${writeResponse.error}`, false, 'error');
          } else {
            Terminal.print(`Saved to ${fullPath}.`, false, 'success');
          }
        } catch (e) { Terminal.print(`wget error: ${e.message}`, false, 'error'); }
      },
      fs_reset: async () => {
        Modal.confirm("Reset File System", "CAUTION: This will erase ALL data in the virtual file system and reset browser history/bookmarks and PEPx metadata. Are you sure?", async (ok) => {
          if(ok) {
            Terminal.print("Resetting backend file system and database...", false, 'warn');
            const response = await window.pywebview.api.reset_vfs_backend();
            if (response.error) {
              Terminal.print(`fs_reset error: ${response.error}`, false, 'error');
            } else {
              Terminal.print(response.message, false, 'success');
              // Re-initialize PEPx metadata after reset
              OBPI.pepxInstance.metadataStore.files = {}; // Clear client-side cache
              await OBPI.pepxInstance.metadataStore.loadFromBackend(); // Load empty or default
              AppManager.apps.pepxExplorer.fileManager?.refreshFileList(); // Refresh explorer if open
            }
          } else {Terminal.print("File system reset cancelled.");}
        });
      },
      exec_dh: (args) => {
        if (!args[0]) { Terminal.print("exec_dh: no code provided.", false, 'error'); return; }
        try { const result = DecHexLang.interpret(args.join('')); Terminal.print(`DecHex Output:\n${result}`); }
        catch (e) { Terminal.print(`DecHex Error: ${e.message}`, false, 'error'); }
      },
      ask_ai: async (args) => {
        if (!args.length) { Terminal.print("ask_ai: No query provided.", false, 'error'); return; }
        const query = args.join(" ");
        if (OBPI.windows['ai-assistant']) {
          AppManager.apps.aiAssistant.handleQuery(query);
          WindowManager.focus('ai-assistant');
        } else {
          AppManager.installedApps['ai_assistant'].launch();
          await new Promise(resolve => setTimeout(resolve, 300));
          AppManager.apps.aiAssistant.handleQuery(query);
        }
      },
      python: async (args) => {
        if (!args.length) { AppManager.installedApps['python_runner'].launch(); return; }
        const codeToRun = args.join(" ");
        const response = await window.pywebview.api.execute_python_code(codeToRun);
        if (response.status === 'success') {
          Terminal.print(`Python Output:\n${response.output}`, false, 'info');
        } else {
          Terminal.print(`Python Error:\n${response.output}`, false, 'error');
        }
        if (!OBPI.windows['python-runner']) AppManager.installedApps['python_runner'].launch();
        WindowManager.focus('python-runner');
        if (AppManager.apps.pythonRunner.outputArea) {
          AppManager.apps.pythonRunner.logOutput(`CLI Executed:\n${codeToRun}\n`, false);
          AppManager.apps.pythonRunner.logOutput(response.output, response.status === 'error');
        }
      },
      run_py_file: async (args) => {
        if (!args[0]) { Terminal.print("run_py_file: missing file path", false, 'error'); return; }
        let filePath = args[0];
        if (!filePath.startsWith('/')) {
          filePath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + filePath;
        }
        try {
          const fileResponse = await window.pywebview.api.get_file_content_backend(filePath);
          if (fileResponse.error) {
            Terminal.print(`run_py_file: ${fileResponse.error}`, false, 'error');
            return;
          }
          const codeContent = fileResponse.content;
          Terminal.print(`Executing Python file: ${filePath}`, false, 'info');
          const execResponse = await window.pywebview.api.execute_python_code(codeContent);
          if (execResponse.status === 'success') {
            Terminal.print(`Python File Output:\n${execResponse.output}`, false, 'info');
          } else {
            Terminal.print(`Python File Error:\n${execResponse.output}`, false, 'error');
          }
          if (!OBPI.windows['python-runner']) AppManager.installedApps['python_runner'].launch();
          WindowManager.focus('python-runner');
          if (AppManager.apps.pythonRunner.outputArea) {
            AppManager.apps.pythonRunner.logOutput(`File Executed: ${filePath}\n`, false);
            AppManager.apps.pythonRunner.logOutput(execResponse.output, execResponse.status === 'error');
          }
        } catch (e) {
          Terminal.print(`run_py_file error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`run_py_file backend call error: ${e.stack}`, 'error');
        }
      },
      lock_instance: () => {
        if (OBPI.desktopElement.requestFullscreen) OBPI.desktopElement.requestFullscreen();
        else if (OBPI.desktopElement.webkitRequestFullscreen) OBPI.desktopElement.webkitRequestFullscreen();
        else if (OBPI.desktopElement.msRequestFullscreen) OBPI.desktopElement.msRequestFullscreen();
        OBPI.isLocked = true; OBPI.fullscreenLockOverlay.style.display = 'block';
        Terminal.print("OBPI instance screen lock requested. Press ESC to exit fullscreen (browser default). Use 'unlock_instance' if OBPI controls it.", false, 'warn');
      },
      unlock_instance: () => {
        if (document.exitFullscreen) document.exitFullscreen();
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
        else if (document.msExitFullscreen) document.msExitFullscreen();
        OBPI.isLocked = false; OBPI.fullscreenLockOverlay.style.display = 'none';
        Terminal.print("OBPI instance screen unlock requested.", false, 'info');
      },
      export: (args) => {
        if (!args[0]) { Terminal.print("export: usage: export VAR_NAME=value", false, 'error'); return; }
        const [name, ...valueParts] = args.join(" ").split('=');
        if (!name || valueParts.length === 0) { Terminal.print("export: invalid format. Use VAR_NAME=value", false, 'error'); return; }
        const value = valueParts.join('=');
        OBPI.envVars[name.trim()] = value.trim().replace(/^"|"$/g, '');
        Terminal.print(`Set ${name.trim()}=${OBPI.envVars[name.trim()]}`, false, 'success');
        if(name.trim() === 'PROMPT') OBPI.config.defaultPrompt = OBPI.envVars[name.trim()];
        Terminal.updatePrompt();
      },
      unset: (args) => {
        if (!args[0]) { Terminal.print("unset: usage: unset VAR_NAME", false, 'error'); return; }
        const varName = args[0].trim();
        if (OBPI.envVars.hasOwnProperty(varName)) {
          delete OBPI.envVars[varName];
          Terminal.print(`Unset ${varName}`, false, 'success');
          if(varName === 'PROMPT') OBPI.config.defaultPrompt = 'guest@OBPI:~# ';
          Terminal.updatePrompt();
        } else { Terminal.print(`unset: variable not found: ${varName}`, false, 'warn'); }
      },
      env: () => {
        Terminal.print("Environment Variables:");
        for (const key in OBPI.envVars) Terminal.print(`  ${key}=${OBPI.envVars[key]}`);
        if (Object.keys(OBPI.envVars).length === 0) Terminal.print("(No environment variables set)");
      },
      alias: (args) => {
        if (args.length === 0) {
          Terminal.print("Current Aliases:");
          for (const key in OBPI.aliases) Terminal.print(`  alias ${key}='${OBPI.aliases[key]}'`);
          if (Object.keys(OBPI.aliases).length === 0) Terminal.print("(No aliases defined)"); return;
        }
        const aliasStr = args.join(" ");
        const match = aliasStr.match(/^([a-zA-Z0-9_-]+)='(.+)'$/);
        if (match && match[1] && match[2]) {
          OBPI.aliases[match[1]] = match[2];
          Terminal.print(`Alias set: ${match[1]} -> ${match[2]}`, false, 'success');
        } else { Terminal.print("alias: usage: alias name='command string'", false, 'error'); }
      },
      unalias: (args) => {
        if (!args[0]) { Terminal.print("unalias: usage: unalias <alias_name>", false, 'error'); return; }
        const aliasName = args[0];
        if (OBPI.aliases[aliasName]) {
          delete OBPI.aliases[aliasName];
          Terminal.print(`Alias removed: ${aliasName}`, false, 'success');
        } else { Terminal.print(`unalias: alias not found: ${aliasName}`, false, 'warn'); }
      },
      exec: async (args) => {
        if (!args[0]) { Terminal.print("exec: missing file path", false, 'error'); return; }
        let filePath = args[0];
        if (!filePath.startsWith('/')) {
          filePath = OBPI.currentPath + (OBPI.currentPath.endsWith('/') ? '' : '/') + filePath;
        }

        try {
          const fileResponse = await window.pywebview.api.get_file_content_backend(filePath);
          if (fileResponse.error) {
            Terminal.print(`exec: cannot access '${args[0]}': ${fileResponse.error}`, false, 'error');
            return;
          }
          const fileContent = fileResponse.content;
          const lastDotIndex = args[0].lastIndexOf('.');
          const fileExtension = lastDotIndex > -1 ? args[0].substring(lastDotIndex + 1).toLowerCase() : '';

          const hasExecPerm = await OBPI.kernel.requestPermission('execute_file', `File: ${args[0]}`);
          if (!hasExecPerm) { Terminal.print(`Execution denied for ${args[0]} by OBPI kernel.`, false, 'warn'); return; }

          if (fileExtension === 'py') AppManager.cliCommands.run_py_file(args);
          else if (fileExtension === 'js') {
            Terminal.print(`Executing JavaScript file (conceptual): ${args[0]}`);
            try { eval(fileContent); Terminal.print(`JavaScript execution finished for ${args[0]}.`, false, 'success'); }
            catch (e) { Terminal.print(`Error executing JS ${args[0]}: ${e.message}`, false, 'error'); }
          } else if (fileExtension === 'obsh') {
            Terminal.print(`Executing OBPI Shell Script: ${args[0]}`, false, 'info');
            const commands = fileContent.split('\n').filter(cmd => cmd.trim() && !cmd.trim().startsWith('#'));
            for (const cmd of commands) { Terminal.print(`$ ${cmd}`, true); await AppManager.executeCommand(cmd); }
            Terminal.print(`Finished executing script ${args[0]}.`, false, 'success');
          } else if (fileExtension === 'dechex' || fileExtension === 'dh') AppManager.cliCommands.exec_dh([fileContent]);
          else if (fileExtension === 'wasm') Terminal.print(`Conceptual execution of WASM file: ${args[0]}. Use 'wasm_core_test' for now.`, false, 'info');
          else Terminal.print(`exec: unknown file type or unsupported extension: .${fileExtension}`, false, 'error');
        } catch (e) {
          Terminal.print(`exec error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`exec backend call error: ${e.stack}`, 'error');
        }
      },
      net: async (args) => {
        if (!args[0]) { Terminal.print("net: missing subcommand (e.g., scan, connect, info)", false, 'error'); return; }
        const subCommand = args[0].toLowerCase();
        if (subCommand === 'scan') {
          Terminal.print("Scanning for virtual WiFi networks...", false, 'info');
          const hasNetPerm = await OBPI.kernel.requestPermission('network_scan', 'NetworkManagerCLI');
          if (!hasNetPerm) { Terminal.print("Network scan permission denied.", false, 'warn'); return; }
          const networks = AppManager.apps.networkManager.getSimulatedNetworks();
          networks.forEach(net => Terminal.print(`  SSID: ${net.ssid.padEnd(20)} Signal: ${net.signal}%  Security: ${net.security}`));
          Terminal.print("Scan complete.", false, 'success');
        } else if (subCommand === 'connect') {
          if (!args[1]) { Terminal.print("net connect: missing SSID", false, 'error'); return; }
          Terminal.print(`Attempting to connect to virtual network: ${args[1]}...`, false, 'info');
          const hasNetPerm = await OBPI.kernel.requestPermission('network_connect', 'NetworkManagerCLI');
          if (!hasNetPerm) { Terminal.print("Network connect permission denied.", false, 'warn'); return; }
          const success = Math.random() > 0.3;
          if (success) { OBPI.envVars['CURRENT_SSID'] = args[1]; Terminal.print(`Successfully connected to ${args[1]}. IP (simulated): 192.168.1.${Math.floor(Math.random()*253)+2}`, false, 'success'); } else Terminal.print(`Failed to connect to ${args[1]}.`, false, 'error');
        } else if (subCommand === 'info') {
          Terminal.print("Simulated Network Interface Info:");
          Terminal.print(`  Status: ${OBPI.envVars['CURRENT_SSID'] ? 'Connected' : 'Disconnected'}`);
          if (OBPI.envVars['CURRENT_SSID']) Terminal.print(`  SSID: ${OBPI.envVars['CURRENT_SSID']}`);
          Terminal.print(`  MAC Address (simulated): FA:KE:MA:C0:AD:DR`);
        } else Terminal.print(`net: unknown subcommand '${subCommand}'. Try 'scan', 'connect <ssid>', or 'info'.`, false, 'error');
      },
      bt: async (args) => {
        if (!args[0]) { Terminal.print("bt: missing subcommand (e.g., scan, pair, info)", false, 'error'); return; }
        const subCommand = args[0].toLowerCase();
        if (subCommand === 'scan') {
          Terminal.print("Scanning for virtual Bluetooth devices...", false, 'info');
          const hasBtPerm = await OBPI.kernel.requestPermission('bluetooth_scan', 'BluetoothManagerCLI');
          if (!hasBtPerm) { Terminal.print("Bluetooth scan permission denied.", false, 'warn'); return; }
          const devices = AppManager.apps.bluetoothManager.getSimulatedDevices();
          devices.forEach(dev => Terminal.print(`  Device: ${dev.name.padEnd(20)} Type: ${dev.type}`));
          Terminal.print("Scan complete.", false, 'success');
        } else if (subCommand === 'pair') {
          if (!args[1]) { Terminal.print("bt pair: missing device name", false, 'error'); return; }
          Terminal.print(`Attempting to pair with virtual device: ${args[1]}...`, false, 'info');
          const hasBtPerm = await OBPI.kernel.requestPermission('bluetooth_pair', 'BluetoothManagerCLI');
          if (!hasBtPerm) { Terminal.print("Bluetooth pair permission denied.", false, 'warn'); return; }
          const success = Math.random() > 0.4;
          if (success) Terminal.print(`Successfully paired with ${args[1]}.`, false, 'success'); else Terminal.print(`Failed to pair with ${args[1]}.`, false, 'error');
        } else Terminal.print(`bt: unknown subcommand '${subCommand}'. Try 'scan' or 'pair <name>'.`, false, 'error');
      },
      theme: (args) => {
        if (!args[0] || (args[0] !== 'light' && args[0] !== 'dark')) { Terminal.print("theme: usage: theme [light|dark]", false, 'error'); Terminal.print(`Current theme: ${OBPI.activeTheme}`); return; }
        AppManager.apps.themeSettings.setTheme(args[0]); Terminal.print(`Theme set to ${args[0]}.`, false, 'success');
      },
      // PEPx CLI commands (metadata now from backend)
      pepx: async (args) => {
        if (!OBPI.pepxInstance) {
          OBPI.pepxInstance = new PEPxStorage();
          await OBPI.pepxInstance.initialize(); // Initialize PEPx storage (loads metadata)
        }
        if (!args[0]) { Terminal.print("pepx: missing subcommand (e.g., ls, stat)", false, 'error'); return; }
        const subCmd = args[0].toLowerCase();
        const pepxPath = args[1] || '/';

        if (subCmd === 'ls') {
          Terminal.print(`PEPx Listing for path: ${pepxPath}`, false, 'info');
          await OBPI.pepxInstance.metadataStore.loadFromBackend(); // Ensure latest metadata
          const files = OBPI.pepxInstance.metadataStore.listFiles(pepxPath);
          if(files.length === 0) Terminal.print("(empty or path not found in PEPx store)");
          files.forEach(f => Terminal.print(`  ${f.name}${f.type === 'folder' ? '/' : ''} (${f.type}, ${AppManager.apps.pepxExplorer.fileManager.formatFileSize(f.size)})`));
        } else if (subCmd === 'stat') {
          Terminal.print(`PEPx Storage Stats:`, false, 'info');
          await OBPI.pepxInstance.metadataStore.loadFromBackend(); // Ensure latest metadata
          Terminal.print(`  Conceptual Capacity: ${AppManager.apps.pepxExplorer.fileManager.formatFileSize(OBPI.pepxInstance.calculateCapacity())}`);
          const allFiles = Object.values(OBPI.pepxInstance.metadataStore.files);
          const totalUsed = allFiles.reduce((sum, f) => sum + (f.storedByteLength || f.size), 0);
          Terminal.print(`  Total Stored (Metadata): ${AppManager.apps.pepxExplorer.fileManager.formatFileSize(totalUsed)} across ${allFiles.length} files/folders.`);
        } else if (subCmd === 'upload') {
          Terminal.print("pepx upload: This CLI command is conceptual. Please use the 'PEPx Explorer' app's Upload button.", false, 'warn');
          Terminal.print("Reason: Direct file access from JS CLI to local user files is restricted by browser security.");
        } else {
          Terminal.print(`pepx: unknown subcommand '${subCmd}'.`, false, 'error');
        }
      },
      sys_info: async () => { // Now fetches from backend
        Terminal.print("Fetching System Information...", false, 'info');
        try {
          const response = await window.pywebview.api.get_system_info_backend();
          if (response.error) {
            Modal.show('System Information Error', `Failed to retrieve system info: ${response.error}`);
            return;
          }
          Terminal.print("System Information:");
          for (const key in response) {
            Terminal.print(`  ${key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()).padEnd(25)}: ${response[key]}`);
          }
        } catch (e) {
          Terminal.print(`sys_info error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`sys_info backend call error: ${e.stack}`, 'error');
        }
      },
      usb_scan: async () => { // New command to trigger USB scan
        Terminal.print("Scanning for USB devices...", false, 'info');
        try {
          const response = await window.pywebview.api.get_usb_devices_backend();
          if (response.error) {
            Terminal.print(`USB scan error: ${response.error}`, false, 'error');
            return;
          }
          if (response.devices && response.devices.length > 0) {
            Terminal.print("Detected USB Devices:");
            response.devices.forEach(dev => {
              Terminal.print(`  - ${dev.product} (${dev.device_type}) [VID: ${dev.vendor_id}, PID: ${dev.product_id}] Bus: ${dev.bus}, Addr: ${dev.address}`);
              if (dev.manufacturer) Terminal.print(`    Manufacturer: ${dev.manufacturer}`);
              if (dev.serial_number) Terminal.print(`    Serial: ${dev.serial_number}`);
            });
          } else {
            Terminal.print("No USB devices detected.");
          }
        } catch (e) {
          Terminal.print(`usb_scan error: ${e.message}`, false, 'error');
          OBPI.kernel.log(`usb_scan backend call error: ${e.stack}`, 'error');
        }
      },
      // Compiler CLI commands
      c_compile: async (args) => {
        if (args.length < 1) { Terminal.print("c_compile: usage: c_compile <file_path>", false, 'error'); return; }
        const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0];
        const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
        if (error) { Terminal.print(`c_compile: ${error}`, false, 'error'); return; }
        Terminal.print(`Compiling C code from ${filePath}...`, false, 'info');
        const response = await window.pywebview.api.compile_and_run_code('c', node.content);
        if (response.error) { Terminal.print(`C Compiler Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`C Compiler Output:\n${response.output}`, false, 'info'); }
      },
      cpp_compile: async (args) => {
        if (args.length < 1) { Terminal.print("cpp_compile: usage: cpp_compile <file_path>", false, 'error'); return; }
        const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0];
        const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
        if (error) { Terminal.print(`cpp_compile: ${error}`, false, 'error'); return; }
        Terminal.print(`Compiling C++ code from ${filePath}...`, false, 'info');
        const response = await window.pywebview.api.compile_and_run_code('cpp', node.content);
        if (response.error) { Terminal.print(`C++ Compiler Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`C++ Compiler Output:\n${response.output}`, false, 'info'); }
      },
      csharp_compile: async (args) => {
        if (args.length < 1) { Terminal.print("csharp_compile: usage: csharp_compile <file_path>", false, 'error'); return; }
        const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0];
        const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
        if (error) { Terminal.print(`csharp_compile: ${error}`, false, 'error'); return; }
        Terminal.print(`Compiling C# code from ${filePath}...`, false, 'info');
        const response = await window.pywebview.api.compile_and_run_code('csharp', node.content);
        if (response.error) { Terminal.print(`C# Compiler Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`C# Compiler Output:\n${response.output}`, false, 'info'); }
      },
      go_compile: async (args) => {
        if (args.length < 1) { Terminal.print("go_compile: usage: go_compile <file_path>", false, 'error'); return; }
        const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0];
        const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
        if (error) { Terminal.print(`go_compile: ${error}`, false, 'error'); return; }
        Terminal.print(`Compiling Go code from ${filePath}...`, false, 'info');
        const response = await window.pywebview.api.compile_and_run_code('go', node.content);
        if (response.error) { Terminal.print(`Go Compiler Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`Go Compiler Output:\n${response.output}`, false, 'info'); }
      },
      rust_compile: async (args) => {
        if (args.length < 1) { Terminal.print("rust_compile: usage: rust_compile <file_path>", false, 'error'); return; }
        const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0];
        const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
        if (error) { Terminal.print(`rust_compile: ${error}`, false, 'error'); return; }
        Terminal.print(`Compiling Rust code from ${filePath}...`, false, 'info');
        const response = await window.pywebview.api.compile_and_run_code('rust', node.content);
        if (response.error) { Terminal.print(`Rust Compiler Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`Rust Compiler Output:\n${response.output}`, false, 'info'); }
      },
      haskell_compile: async (args) => {
        if (args.length < 1) { Terminal.print("haskell_compile: usage: haskell_compile <file_path>", false, 'error'); return; }
        const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0];
        const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
        if (error) { Terminal.print(`haskell_compile: ${error}`, false, 'error'); return; }
        Terminal.print(`Compiling Haskell code from ${filePath}...`, false, 'info');
        const response = await window.pywebview.api.compile_and_run_code('haskell', node.content);
        if (response.error) { Terminal.print(`Haskell Compiler Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`Haskell Compiler Output:\n${response.output}`, false, 'info'); }
      },
      cobol_compile: async (args) => {
        if (args.length < 1) { Terminal.print("cobol_compile: usage: cobol_compile <file_path>", false, 'error'); return; }
        const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0];
        const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
        if (error) { Terminal.print(`cobol_compile: ${error}`, false, 'error'); return; }
        Terminal.print(`Compiling Cobol code from ${filePath}...`, false, 'info');
        const response = await window.pywebview.api.compile_and_run_code('cobol', node.content);
        if (response.error) { Terminal.print(`Cobol Compiler Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`Cobol Compiler Output:\n${response.output}`, false, 'info'); }
      },
      fortran_compile: async (args) => {
        if (args.length < 1) { Terminal.print("fortran_compile: usage: fortran_compile <file_path>", false, 'error'); return; }
        const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0];
        const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
        if (error) { Terminal.print(`fortran_compile: ${error}`, false, 'error'); return; }
        Terminal.print(`Compiling Fortran code from ${filePath}...`, false, 'info');
        const response = await window.pywebview.api.compile_and_run_code('fortran', node.content);
        if (response.error) { Terminal.print(`Fortran Compiler Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`Fortran Compiler Output:\n${response.output}`, false, 'info'); }
      },
      lua_run: async (args) => {
        if (args.length < 1) { Terminal.print("lua_run: usage: lua_run <file_path>", false, 'error'); return; }
        const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0];
        const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
        if (error) { Terminal.print(`lua_run: ${error}`, false, 'error'); return; }
        Terminal.print(`Running Lua code from ${filePath}...`, false, 'info');
        const response = await window.pywebview.api.compile_and_run_code('lua', node.content);
        if (response.error) { Terminal.print(`Lua Runner Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`Lua Output:\n${response.output}`, false, 'info'); }
      },
      emcc_compile: async (args) => {
        if (args.length < 2) { Terminal.print("emcc_compile: usage: emcc_compile <lang> <file_path>", false, 'error'); return; }
        const lang = args[0].toLowerCase();
        const filePath = args[1].startsWith('/') ? args[1] : OBPI.currentPath + args[1];
        const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
        if (error) { Terminal.print(`emcc_compile: ${error}`, false, 'error'); return; }
        Terminal.print(`Conceptually compiling ${lang.toUpperCase()} code from ${filePath} to WASM/JS...`, false, 'info');
        const response = await window.pywebview.api.compile_and_run_code('emcc', node.content, lang);
        if (response.error) { Terminal.print(`EMCC Conceptual Compiler Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`EMCC Conceptual Output:\n${response.output}`, false, 'info'); }
      },
      hex_to_webgl: async (args) => {
        if (args.length < 1) { Terminal.print("hex_to_webgl: usage: hex_to_webgl <hex_string_or_file_path>", false, 'error'); return; }
        let hexInput = args[0];
        let hexCode;

        if (hexInput.startsWith('/')) { // Assume file path
          const filePath = hexInput;
          const {node, error} = await AppManager.cliCommands.get_file_content_from_vfs(filePath);
          if (error) { Terminal.print(`hex_to_webgl: Could not read hex from file: ${error}`, false, 'error'); return; }
          hexCode = node.content.trim();
          Terminal.print(`Reading hex from file: ${filePath}`, false, 'info');
        } else { // Assume direct hex string
          hexCode = hexInput;
        }

        Terminal.print(`Conceptually compiling hex to WebGL binary bytecode...`, false, 'info');
        const response = await window.pywebview.api.compile_hex_to_webgl_backend(hexCode);
        if (response.error) { Terminal.print(`WebGL Compiler Error: ${response.error}`, false, 'error'); }
        else { Terminal.print(`WebGL Compiler Output:\n${response.output}`, false, 'info'); }
      },
      // Helper to get file content for compiler commands
      get_file_content_from_vfs: async (filePath) => {
        const fileResponse = await window.pywebview.api.get_file_content_backend(filePath);
        if (fileResponse.error) {
          return {node: null, error: fileResponse.error};
        }
        return {node: {content: fileResponse.content, type: 'file'}, error: null};
      }
    },
    cliCommandDescriptions: {
      help: "Show this help message or help for a specific command.",
      man: "Display the manual page for a command.",
      pkg_build: "Simulate building a CLI package and placing it in /bin.",
      process_list: "List currently running applications/windows.",
      resource_monitor: "Display simulated CPU and RAM usage.",
      date: "Display the current date and time.", clear: "Clear the terminal screen.", exit: "Close the terminal window.", echo: "Display a line of text.", pwd: "Print name of current/working directory.",
      ls: "List directory contents (VFS).", cd: "Change the current directory (VFS).", cat: "Concatenate files and print on the standard output (VFS).", mkdir: "Create a new directory (VFS).", write: "Write text to a file (VFS). Usage: write <filename> \"text\"",
      rm: "Remove files or directories (VFS). Use 'rm -r' for recursive. Usage: rm [-r] <path>",
      mv: "Move/rename files or directories (VFS). Usage: mv <source> <destination>",
      cp: "Copy files or directories (VFS). Usage: cp <source> <destination>",
      run: "Launch a pre-defined application. Usage: run <app_id>", install: "Conceptually 'install' an application. Usage: install <app_id_or_url>", curl: "Transfer data from or to a server. Usage: curl <url>", wget: "Download files from the network. Usage: wget <url> [-O=filename]",
      fs_reset: "Reset the VFS file system and browser data to its default state.",
      exec_dh: "Execute DecHex language code. Usage: exec_dh <hex_code_string>", ask_ai: "Send a query to the AI Assistant. Usage: ask_ai \"your question\"",
      python: "Open Python Runner or execute Python code directly. Usage: python \"print('hello')\"",
      run_py_file: "Execute a Python script from the VFS. Usage: run_py_file <path/to/script.py>",
      lock_instance: "Request fullscreen lock for the OBPI instance.",
      unlock_instance: "Request to exit fullscreen lock.",
      export: "Set an environment variable. Usage: export VAR=value",
      unset: "Unset an environment variable. Usage: unset VAR",
      env: "Display environment variables.",
      alias: "Define or display command aliases. Usage: alias name='command'",
      unalias: "Remove an alias. Usage: unalias <name>",
      exec: "Execute a file from VFS based on its extension (.py, .js, .obsh, .dechex). Usage: exec <filepath>",
      net: "Simulated network commands. Usage: net <scan|connect|info>",
      bt: "Simulated Bluetooth commands. Usage: bt <scan|pair>",
      theme: "Change OBPI theme. Usage: theme <light|dark>",
      pepx: "Interact with PEPx pixel storage. Usage: pepx &lt;ls|stat|upload&gt;",
      sys_info: "Display detailed system information from host machine.",
      usb_scan: "Scan for and list connected USB devices on host system.",
                                                        c_compile: "Compile and run C code from VFS. Requires GCC on host. Usage: c_compile <file.c>",
      cpp_compile: "Compile and run C++ code from VFS. Requires G++ on host. Usage: cpp_compile <file.cpp>",
      csharp_compile: "Compile and run C# code from VFS. Requires .NET SDK on host. Usage: csharp_compile <file.cs>",
      go_compile: "Compile and run Go code from VFS. Requires Go compiler on host. Usage: go_compile <file.go>",
      rust_compile: "Compile and run Rust code from VFS. Requires Rust compiler on host. Usage: rust_compile <file.rs>",
      haskell_compile: "Compile and run Haskell code from VFS. Requires GHC on host. Usage: haskell_compile <file.hs>",
      cobol_compile: "Compile and run Cobol code from VFS. Requires GnuCOBOL on host. Usage: cobol_compile <file.cbl>",
      fortran_compile: "Compile and run Fortran code from VFS. Requires GFortran on host. Usage: fortran_compile <file.f90>",
      lua_run: "Run Lua code from VFS. Requires Lua interpreter on host. Usage: lua_run <file.lua>",
      emcc_compile: "Conceptually compile C/C++ to WebAssembly/JS. Requires Emscripten SDK on host. Usage: emcc_compile <lang> <file>",
      hex_to_webgl: "Conceptually compile hexadecimal code to WebGL binary bytecode. Usage: hex_to_webgl <hex_string_or_file>"
    },
    // Detailed help pages for CLI commands
    cliHelpPages: {
      help: "Displays a list of available commands or detailed help for a specific command.\nUsage: help [command_name]\nExample: help ls",
      man: "Displays the manual page for a specified command, providing more in-depth information.\nUsage: man <command_name>\nExample: man curl",
      pkg_build: "Simulates the process of building a new command-line package and makes it executable in the /bin directory. This is a conceptual build process.\nUsage: pkg_build <package_name>\nExample: pkg_build mytool",
      process_list: "Lists all currently active application windows and their simulated process IDs (PIDs) and states.",
      resource_monitor: "Displays a conceptual overview of system resource usage, such as CPU and RAM. Note: This is a simulated output that fetches some real system info from the backend.",
      ls: "Lists the contents of a directory. By default, lists the current directory.\nUsage: ls [directory_path]\nExample: ls /home/guest/documents",
      cd: "Changes the current working directory. Use 'cd ..' to go up one level, or 'cd /' for root.\nUsage: cd [directory_path]\nExample: cd /home/guest",
      cat: "Displays the content of a specified file on the terminal.\nUsage: cat <file_path>\nExample: cat /home/guest/readme.txt",
      mkdir: "Creates a new directory at the current path or a specified path.\nUsage: mkdir <directory_name>\nExample: mkdir new_folder",
      write: "Writes specified text content to a file. If the file exists, it will be overwritten.\nUsage: write <filename> \"<text_content>\"\nExample: write my_notes.txt \"This is a test note.\"",
      rm: "Removes files or directories. Use the '-r' flag for recursive deletion of directories.\nUsage: rm [-r] <path>\nExample: rm my_old_file.txt\nExample: rm -r my_directory/",
      mv: "Moves or renames a file or directory from a source path to a destination path.\nUsage: mv <source_path> <destination_path>\nExample: mv old_name.txt new_name.txt",
      cp: "Copies a file or directory from a source path to a destination path.\nUsage: cp <source_path> <destination_path>\nExample: cp original.txt copy.txt",
      run: "Launches an installed application by its application ID.\nUsage: run <app_id>\nExample: run py_ide",
      install: "Conceptually simulates the installation of an application. In this environment, new apps are added by modifying source code.\nUsage: install <app_identifier>",
      curl: "A command-line tool for transferring data with URLs. Fetches content from external web URLs.\nUsage: curl <url>\nExample: curl https://example.com",
      wget: "A command-line utility for retrieving content from web servers. Downloads content from a specified URL and saves it as a file in the Virtual File System (VFS).\nUsage: wget <url> [-O=filename]\nExample: wget https://example.com/data.txt -O=mydata.txt",
      fs_reset: "WARNING: Resets the entire Virtual File System (VFS) and clears all browser history, bookmarks, and PEPx metadata. This action is irreversible.\nUsage: fs_reset",
      exec_dh: "Executes DecHex language code. DecHex is a simple, custom hexadecimal opcode language.\nUsage: exec_dh <hex_code_string>\nExample: exec_dh 0D050E0C",
      ask_ai: "Sends a natural language query to the AI Assistant. The assistant can answer questions, generate conceptual code, and speak responses.\nUsage: ask_ai \"your question here\"\nExample: ask_ai \"generate C hex for printing hello world\"",
      python: "Executes Python code directly or launches the Python Runner application.\nUsage: python \"print('Hello')\"\nUsage: python (to launch runner)",
      run_py_file: "Executes a Python script located in the Virtual File System.\nUsage: run_py_file <path_to_script.py>\nExample: run_py_file /home/guest/python_scripts/hello.py",
      lock_instance: "Requests the OBPI instance to enter fullscreen mode, effectively locking the screen. Press ESC to exit fullscreen (browser default).\nUsage: lock_instance",
      unlock_instance: "Requests the OBPI instance to exit fullscreen mode.\nUsage: unlock_instance",
      export: "Sets a new environment variable or updates an existing one. Variables are used by the shell and some applications.\nUsage: export VAR_NAME=value\nExample: export USER=admin",
      unset: "Removes an environment variable.\nUsage: unset VAR_NAME\nExample: unset USER",
      env: "Displays a list of all currently set environment variables.",
      alias: "Defines a new command alias or lists existing aliases. Aliases provide shortcuts for longer commands.\nUsage: alias name='command string'\nExample: alias ll='ls -l'",
                                                                                                          unalias:
                                                                                                          "Removes a
                                                                                                          previously
                                                                                                          defined
                                                                                                          command
                                                                                                          alias.\nUsage:
                                                                                                          unalias
                                                                                                          <alias_name>
                                                                                                            \nExample:
                                                                                                            unalias ll",
                                                                                                            exec:
                                                                                                            "Executes a
                                                                                                            file from
                                                                                                            VFS based on
                                                                                                            its
                                                                                                            extension
                                                                                                            (e.g., .py,
                                                                                                            .js, .obsh,
                                                                                                            .dechex).
                                                                                                            This command
                                                                                                            requires
                                                                                                            execution
                                                                                                            permission.\nUsage:
                                                                                                            exec
                                                                                                            <file_path>
                                                                                                              \nExample:
                                                                                                              exec
                                                                                                              /home/guest/myscript.py",
                                                                                                              net:
                                                                                                              "Simulated
                                                                                                              network
                                                                                                              management
                                                                                                              commands.
                                                                                                              Allows
                                                                                                              scanning
                                                                                                              for
                                                                                                              networks,
                                                                                                              connecting,
                                                                                                              and
                                                                                                              viewing
                                                                                                              network
                                                                                                              info.\nUsage:
                                                                                                              net
                                                                                                              <scan
                                                                                                              |connect
                                                                                                              <ssid>
                                                                                                                |info>\nExample:
                                                                                                                net
                                                                                                                scan",
                                                                                                                bt:
                                                                                                                "Simulated
                                                                                                                Bluetooth
                                                                                                                device
                                                                                                                management
                                                                                                                commands.
                                                                                                                Allows
                                                                                                                scanning
                                                                                                                for
                                                                                                                devices
                                                                                                                and
                                                                                                                simulating
                                                                                                                pairing.\nUsage:
                                                                                                                bt <scan|pair <device_name>>\nExample:
                                                                                                                  bt
                                                                                                                  scan",
                                                                                                                  theme:
                                                                                                                  "Changes
                                                                                                                  the
                                                                                                                  visual
                                                                                                                  theme
                                                                                                                  of the
                                                                                                                  OBPI
                                                                                                                  interface
                                                                                                                  between
                                                                                                                  'light'
                                                                                                                  and
                                                                                                                  'dark'
                                                                                                                  modes.\nUsage:
                                                                                                                  theme
                                                                                                                  <light
                                                                                                                  |dark>\nExample:
                                                                                                                  theme
                                                                                                                  light",
                                                                                                                  pepx:
                                                                                                                  "Interacts
                                                                                                                  with
                                                                                                                  the
                                                                                                                  PEPx
                                                                                                                  pixel
                                                                                                                  storage
                                                                                                                  system.
                                                                                                                  Allows
                                                                                                                  listing
                                                                                                                  stored
                                                                                                                  files
                                                                                                                  and
                                                                                                                  viewing
                                                                                                                  storage
                                                                                                                  statistics.\nUsage:
                                                                                                                  pepx
                                                                                                                  <ls
                                                                                                                  |stat>
                                                                                                                  [path]\nExample:
                                                                                                                  pepx
                                                                                                                  ls
                                                                                                                  /PixelDocs",
                                                                                                                  sys_info:
                                                                                                                  "Displays
                                                                                                                  detailed
                                                                                                                  system
                                                                                                                  information
                                                                                                                  about
                                                                                                                  the
                                                                                                                  host
                                                                                                                  machine,
                                                                                                                  fetched
                                                                                                                  from
                                                                                                                  the
                                                                                                                  backend.",
                                                                                                                  usb_scan:
                                                                                                                  "Scans
                                                                                                                  for
                                                                                                                  and
                                                                                                                  lists
                                                                                                                  connected
                                                                                                                  USB
                                                                                                                  devices
                                                                                                                  on the
                                                                                                                  host
                                                                                                                  system
                                                                                                                  using
                                                                                                                  pyusb.",
                                                                                                                  c_compile:
                                                                                                                  "Compiles
                                                                                                                  and
                                                                                                                  runs C
                                                                                                                  code
                                                                                                                  from a
                                                                                                                  VFS
                                                                                                                  file.
                                                                                                                  Requires
                                                                                                                  GCC to
                                                                                                                  be
                                                                                                                  installed
                                                                                                                  on the
                                                                                                                  host
                                                                                                                  system.\nUsage:
                                                                                                                  c_compile
                                                                                                                  <file.c>
                                                                                                                    ",
                                                                                                                    cpp_compile:
                                                                                                                    "Compiles
                                                                                                                    and
                                                                                                                    runs
                                                                                                                    C++
                                                                                                                    code
                                                                                                                    from
                                                                                                                    a
                                                                                                                    VFS
                                                                                                                    file.
                                                                                                                    Requires
                                                                                                                    G++
                                                                                                                    to
                                                                                                                    be
                                                                                                                    installed
                                                                                                                    on
                                                                                                                    the
                                                                                                                    host
                                                                                                                    system.\nUsage:
                                                                                                                    cpp_compile
                                                                                                                    <file.cpp>
                                                                                                                      ",
                                                                                                                      csharp_compile:
                                                                                                                      "Compiles
                                                                                                                      and
                                                                                                                      runs
                                                                                                                      C#
                                                                                                                      code
                                                                                                                      from
                                                                                                                      a
                                                                                                                      VFS
                                                                                                                      file.
                                                                                                                      Requires
                                                                                                                      .NET
                                                                                                                      SDK
                                                                                                                      (dotnet
                                                                                                                      CLI)
                                                                                                                      to
                                                                                                                      be
                                                                                                                      installed
                                                                                                                      on
                                                                                                                      the
                                                                                                                      host
                                                                                                                      system.\nUsage:
                                                                                                                      csharp_compile
                                                                                                                      <file.cs>
                                                                                                                        ",
                                                                                                                        go_compile:
                                                                                                                        "Compiles
                                                                                                                        and
                                                                                                                        runs
                                                                                                                        Go
                                                                                                                        code
                                                                                                                        from
                                                                                                                        a
                                                                                                                        VFS
                                                                                                                        file.
                                                                                                                        Requires
                                                                                                                        Go
                                                                                                                        compiler
                                                                                                                        to
                                                                                                                        be
                                                                                                                        installed
                                                                                                                        on
                                                                                                                        the
                                                                                                                        host
                                                                                                                        system.\nUsage:
                                                                                                                        go_compile
                                                                                                                        <file.go>
                                                                                                                          ",
                                                                                                                          rust_compile:
                                                                                                                          "Compiles
                                                                                                                          and
                                                                                                                          runs
                                                                                                                          Rust
                                                                                                                          code
                                                                                                                          from
                                                                                                                          a
                                                                                                                          VFS
                                                                                                                          file.
                                                                                                                          Requires
                                                                                                                          Rust
                                                                                                                          compiler
                                                                                                                          (rustc)
                                                                                                                          to
                                                                                                                          be
                                                                                                                          installed
                                                                                                                          on
                                                                                                                          the
                                                                                                                          host
                                                                                                                          system.\nUsage:
                                                                                                                          rust_compile
                                                                                                                          <file.rs>
                                                                                                                            ",
                                                                                                                            haskell_compile:
                                                                                                                            "Compiles
                                                                                                                            and
                                                                                                                            runs
                                                                                                                            Haskell
                                                                                                                            code
                                                                                                                            from
                                                                                                                            a
                                                                                                                            VFS
                                                                                                                            file.
                                                                                                                            Requires
                                                                                                                            GHC
                                                                                                                            (Glasgow
                                                                                                                            Haskell
                                                                                                                            Compiler)
                                                                                                                            to
                                                                                                                            be
                                                                                                                            installed
                                                                                                                            on
                                                                                                                            the
                                                                                                                            host
                                                                                                                            system.\nUsage:
                                                                                                                            haskell_compile
                                                                                                                            <file.hs>
                                                                                                                              ",
                                                                                                                              cobol_compile:
                                                                                                                              "Compiles
                                                                                                                              and
                                                                                                                              runs
                                                                                                                              Cobol
                                                                                                                              code
                                                                                                                              from
                                                                                                                              a
                                                                                                                              VFS
                                                                                                                              file.
                                                                                                                              Requires
                                                                                                                              GnuCOBOL
                                                                                                                              (cobc)
                                                                                                                              to
                                                                                                                              be
                                                                                                                              installed
                                                                                                                              on
                                                                                                                              the
                                                                                                                              host
                                                                                                                              system.\nUsage:
                                                                                                                              cobol_compile
                                                                                                                              <file.cbl>
                                                                                                                                ",
                                                                                                                                fortran_compile:
                                                                                                                                "Compiles
                                                                                                                                and
                                                                                                                                runs
                                                                                                                                Fortran
                                                                                                                                code
                                                                                                                                from
                                                                                                                                a
                                                                                                                                VFS
                                                                                                                                file.
                                                                                                                                Requires
                                                                                                                                GFortran
                                                                                                                                to
                                                                                                                                be
                                                                                                                                installed
                                                                                                                                on
                                                                                                                                the
                                                                                                                                host
                                                                                                                                system.\nUsage:
                                                                                                                                fortran_compile
                                                                                                                                <file.f90>
                                                                                                                                  ",
                                                                                                                                  lua_run:
                                                                                                                                  "Runs
                                                                                                                                  Lua
                                                                                                                                  code
                                                                                                                                  from
                                                                                                                                  a
                                                                                                                                  VFS
                                                                                                                                  file.
                                                                                                                                  Requires
                                                                                                                                  Lua
                                                                                                                                  interpreter
                                                                                                                                  to
                                                                                                                                  be
                                                                                                                                  installed
                                                                                                                                  on
                                                                                                                                  the
                                                                                                                                  host
                                                                                                                                  system.\nUsage:
                                                                                                                                  lua_run
                                                                                                                                  <file.lua>
                                                                                                                                    ",
                                                                                                                                    emcc_compile:
                                                                                                                                    "Conceptually
                                                                                                                                    compiles
                                                                                                                                    C/C++
                                                                                                                                    code
                                                                                                                                    from
                                                                                                                                    a
                                                                                                                                    VFS
                                                                                                                                    file
                                                                                                                                    to
                                                                                                                                    WebAssembly
                                                                                                                                    (WASM)
                                                                                                                                    and
                                                                                                                                    JavaScript.
                                                                                                                                    Requires
                                                                                                                                    Emscripten
                                                                                                                                    SDK
                                                                                                                                    (emcc)
                                                                                                                                    to
                                                                                                                                    be
                                                                                                                                    installed
                                                                                                                                    on
                                                                                                                                    the
                                                                                                                                    host
                                                                                                                                    system.
                                                                                                                                    This
                                                                                                                                    is
                                                                                                                                    a
                                                                                                                                    conceptual
                                                                                                                                    representation.\nUsage:
                                                                                                                                    emcc_compile
                                                                                                                                    <lang>
                                                                                                                                      &lt;file.c/cpp&gt;",
                                                                                                                                      hex_to_webgl:
                                                                                                                                      "Conceptually
                                                                                                                                      compiles
                                                                                                                                      hexadecimal
                                                                                                                                      code
                                                                                                                                      to
                                                                                                                                      WebGL
                                                                                                                                      binary
                                                                                                                                      bytecode
                                                                                                                                      and
                                                                                                                                      GLSL
                                                                                                                                      shaders.
                                                                                                                                      This
                                                                                                                                      is
                                                                                                                                      a
                                                                                                                                      simulation
                                                                                                                                      of
                                                                                                                                      a
                                                                                                                                      complex
                                                                                                                                      process.\nUsage:
                                                                                                                                      hex_to_webgl
                                                                                                                                      <hex_string_or_file_path>
                                                                                                                                        "
                                                                                                                                        },
                                                                                                                                        //
                                                                                                                                        Conceptual
                                                                                                                                        Man
                                                                                                                                        Pages
                                                                                                                                        for
                                                                                                                                        CLI
                                                                                                                                        commands
                                                                                                                                        (expanded)
                                                                                                                                        cliManPages:
                                                                                                                                        {
                                                                                                                                        ls:
                                                                                                                                        `LS(1)
                                                                                                                                        LS(1)
                                                                                                                                        NAME
       ls - list directory contents

SYNOPSIS
       ls [OPTION]... [FILE]...

DESCRIPTION
       List information about the FILEs (the current directory by default).
       Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

       This is a simulated 'ls' command operating on the Virtual File System (VFS).
       It interacts with the OBPI backend to retrieve directory contents.

OPTIONS
       [FILE]...
              Specify directory or file paths to list. If omitted, the current
              working directory is listed.

EXAMPLES
       ls
              List contents of the current directory.

       ls /home/guest
              List contents of the /home/guest directory.

       ls /bin/mytool
              List details of a specific file (if it exists).

SEE ALSO
       cd(1), cat(1), mkdir(1)

OBPI CLI                                                              LS(1)
            `,
      cat: `CAT(1)                                                             CAT(1)
NAME
       cat - concatenate files and print on the standard output

SYNOPSIS
       cat [OPTION]... [FILE]...

DESCRIPTION
       Concatenate FILE(s) to standard output.

       This is a simulated 'cat' command operating on the Virtual File System (VFS).
       It retrieves the content of a specified file from the OBPI backend and
       displays it in the terminal.

OPTIONS
       [FILE]...
              Specify the path to the file whose content you want to display.

EXAMPLES
       cat /home/guest/readme.txt
              Display the content of 'readme.txt'.

       cat my_script.py
              Display the content of 'my_script.py' in the current directory.

SEE ALSO
       ls(1), write(1)

OBPI CLI                                                             CAT(1)
            `,
      write: `WRITE(1)                                                           WRITE(1)
NAME
       write - write text content to a file in the VFS

SYNOPSIS
       write FILE "TEXT_CONTENT"

DESCRIPTION
       Writes the specified TEXT_CONTENT to the given FILE path within the
       Virtual File System (VFS). If the file already exists, its content will
       be overwritten. If the file does not exist, it will be created.

       This command interacts with the OBPI backend to perform file write operations.

ARGUMENTS
       FILE
              The path to the file you wish to write to. This can be a relative
              path from the current directory or an absolute path starting with '/'.

       "TEXT_CONTENT"
              The text content to write. It must be enclosed in double quotes.

EXAMPLES
       write my_document.txt "Hello, this is my document."
              Creates or overwrites 'my_document.txt' in the current directory
              with the specified text.

       write /home/guest/scripts/new_script.py "print('Hello from script!')"
              Creates or overwrites 'new_script.py' in the specified path.

SEE ALSO
       cat(1), mkdir(1)

OBPI CLI                                                           WRITE(1)
            `,
      rm: `RM(1)                                                              RM(1)
NAME
       rm - remove files or directories

SYNOPSIS
       rm [OPTION]... FILE...
       rm -r DIRECTORY...

DESCRIPTION
       Remove (delete) the FILE(s) or DIRECTORY(ies) from the Virtual File System (VFS).

       This command interacts with the OBPI backend to perform deletion operations.

OPTIONS
       -r, -R, --recursive
              Remove directories and their contents recursively. Without this
              option, 'rm' will only remove empty directories.

ARGUMENTS
       FILE...
              Specify one or more files to remove.

       DIRECTORY...
              Specify one or more directories to remove.

EXAMPLES
       rm my_old_file.txt
              Delete 'my_old_file.txt' in the current directory.

       rm -r empty_folder/
              Delete an empty directory named 'empty_folder'.

       rm -r project_data/
              Recursively delete the 'project_data' directory and all its contents.

SEE ALSO
       mkdir(1), mv(1), cp(1)

OBPI CLI                                                             RM(1)
            `,
      mv: `MV(1)                                                              MV(1)
NAME
       mv - move (rename) files or directories

SYNOPSIS
       mv [OPTION]... SOURCE DESTINATION

DESCRIPTION
       Rename SOURCE to DESTINATION, or move SOURCE(s) to DIRECTORY.

       This command interacts with the OBPI backend to perform move/rename operations
       within the Virtual File System (VFS).

ARGUMENTS
       SOURCE
              The path to the file or directory you wish to move or rename.

       DESTINATION
              The new path or name for the SOURCE. If DESTINATION is an existing
              directory, SOURCE will be moved into it. If DESTINATION is a new
              name, SOURCE will be renamed to it.

EXAMPLES
       mv old_name.txt new_name.txt
              Renames 'old_name.txt' to 'new_name.txt' in the current directory.

       mv my_file.txt /home/guest/documents/
              Moves 'my_file.txt' from the current directory to '/home/guest/documents/'.

       mv my_folder/ new_location/my_folder_renamed/
              Moves 'my_folder' and renames it to 'my_folder_renamed' within 'new_location'.

SEE ALSO
       cp(1), rm(1)

OBPI CLI                                                             MV(1)
            `,
      cp: `CP(1)                                                              CP(1)
NAME
       cp - copy files and directories

SYNOPSIS
       cp [OPTION]... SOURCE DESTINATION

DESCRIPTION
       Copy SOURCE to DESTINATION, or multiple SOURCE(s) to DIRECTORY.

       This command interacts with the OBPI backend to perform copy operations
       within the Virtual File System (VFS).

ARGUMENTS
       SOURCE
              The path to the file or directory you wish to copy.

       DESTINATION
              The target path for the copy. If DESTINATION is an existing
              directory, SOURCE will be copied into it. If DESTINATION is a new
              file name, SOURCE will be copied to that new file.

EXAMPLES
       cp original.txt copy.txt
              Creates 'copy.txt' as a duplicate of 'original.txt' in the current directory.

       cp my_document.txt /home/guest/backups/
              Copies 'my_document.txt' to the '/home/guest/backups/' directory.

       cp -r my_project/ /home/guest/archives/
              Recursively copies the 'my_project' directory and its contents to
              '/home/guest/archives/'. (Note: '-r' is conceptual for this CLI,
              backend handles recursive copy for directories).

SEE ALSO
       mv(1), rm(1)

OBPI CLI                                                             CP(1)
            `,
      curl: `CURL(1)                                                            CURL(1)
NAME
       curl - transfer a URL

SYNOPSIS
       curl [options] [URL...]

DESCRIPTION
       This is a simulated 'curl' command. It fetches the content from a specified
       URL and displays a truncated version of it in the terminal.

       It uses the browser's Fetch API to retrieve data from the internet.

OPTIONS
       [URL...]
              Specify one or more URLs to retrieve. Only the first URL is processed.

EXAMPLES
       curl https://example.com
              Fetches and displays content from example.com.

SEE ALSO
       wget(1)

OBPI CLI                                                           CURL(1)
            `,
      wget: `WGET(1)                                                            WGET(1)
NAME
       wget - retrieve files from the Web

SYNOPSIS
       wget [OPTION]... [URL]...

DESCRIPTION
       This is a simulated 'wget' command. It downloads content from a specified URL
       and saves it as a file in the Virtual File System (VFS).

       It uses the browser's Fetch API for download and the OBPI backend for file storage.

OPTIONS
       -O=FILENAME
              Save the downloaded file as FILENAME. If omitted, the filename is
              derived from the URL.

ARGUMENTS
       [URL]...
              Specify the URL of the file to download. Only the first URL is processed.

EXAMPLES
       wget https://example.com/data.txt
              Downloads 'data.txt' and saves it to the current VFS directory.

       wget https://example.com/image.jpg -O=my_image.jpg
              Downloads 'image.jpg' and saves it as 'my_image.jpg' in the VFS.

SEE ALSO
       curl(1), write(1)

OBPI CLI                                                           WGET(1)
            `,
      // Add more man pages here for other commands as needed
      usb_scan: `USB_SCAN(1)                                                        USB_SCAN(1)
NAME
       usb_scan - scan for and list connected USB devices

SYNOPSIS
       usb_scan

DESCRIPTION
       This command scans the host system for connected USB devices and displays
       information about them, including Vendor ID, Product ID, Manufacturer,
       Product Name, and device type (e.g., Keyboard/Mouse, Mass Storage, Webcam).

       It uses the 'pyusb' Python library on the backend to interact with the
       host's USB subsystem. Requires 'libusb' to be installed on the host.

EXAMPLES
       usb_scan
              Lists all detected USB devices.

SEE ALSO
       peripheral_manager(1)

OBPI CLI                                                        USB_SCAN(1)
            `,
      c_compile: `C_COMPILE(1)                                                       C_COMPILE(1)
NAME
       c_compile - compile and run C code

SYNOPSIS
       c_compile FILE.c

DESCRIPTION
       This command compiles a C source file from the Virtual File System (VFS)
       and attempts to run the resulting executable.

       It uses the 'gcc' compiler on the host system. 'gcc' must be installed
       and accessible in the system's PATH.

ARGUMENTS
       FILE.c
              The path to the C source file (.c) within the VFS.

EXAMPLES
       c_compile /home/guest/my_program.c
              Compiles and runs 'my_program.c'.

SEE ALSO
       cpp_compile(1), python(1), exec(1)

OBPI CLI                                                       C_COMPILE(1)
            `,
      cpp_compile: `CPP_COMPILE(1)                                                     CPP_COMPILE(1)
NAME
       cpp_compile - compile and run C++ code

SYNOPSIS
       cpp_compile FILE.cpp

DESCRIPTION
       This command compiles a C++ source file from the Virtual File System (VFS)
       and attempts to run the resulting executable.

       It uses the 'g++' compiler on the host system. 'g++' must be installed
       and accessible in the system's PATH.

ARGUMENTS
       FILE.cpp
              The path to the C++ source file (.cpp) within the VFS.

EXAMPLES
       cpp_compile /home/guest/my_program.cpp
              Compiles and runs 'my_program.cpp'.

SEE ALSO
       c_compile(1), python(1), exec(1)

OBPI CLI                                                       CPP_COMPILE(1)
            `,
      csharp_compile: `CSHARP_COMPILE(1)                                                  CSHARP_COMPILE(1)
NAME
       csharp_compile - compile and run C# code

SYNOPSIS
       csharp_compile FILE.cs

DESCRIPTION
       This command compiles a C# source file from the Virtual File System (VFS)
       and attempts to run the resulting executable.

       It uses the '.NET SDK' (dotnet CLI) on the host system. The 'dotnet'
       command must be installed and accessible in the system's PATH.

ARGUMENTS
       FILE.cs
              The path to the C# source file (.cs) within the VFS.

EXAMPLES
       csharp_compile /home/guest/my_app.cs
              Compiles and runs 'my_app.cs'.

SEE ALSO
       python(1), exec(1)

OBPI CLI                                                     CSHARP_COMPILE(1)
            `,
      go_compile: `GO_COMPILE(1)                                                      GO_COMPILE(1)
NAME
       go_compile - compile and run Go code

SYNOPSIS
       go_compile FILE.go

DESCRIPTION
       This command compiles a Go source file from the Virtual File System (VFS)
       and attempts to run the resulting executable.

       It uses the 'Go compiler' ('go') on the host system. 'go' must be installed
       and accessible in the system's PATH.

ARGUMENTS
       FILE.go
              The path to the Go source file (.go) within the VFS.

EXAMPLES
       go_compile /home/guest/my_program.go
              Compiles and runs 'my_program.go'.

SEE ALSO
       python(1), exec(1)

OBPI CLI                                                         GO_COMPILE(1)
            `,
      rust_compile: `RUST_COMPILE(1)                                                    RUST_COMPILE(1)
NAME
       rust_compile - compile and run Rust code

SYNOPSIS
       rust_compile FILE.rs

DESCRIPTION
       This command compiles a Rust source file from the Virtual File System (VFS)
       and attempts to run the resulting executable.

       It uses the 'Rust compiler' ('rustc') on the host system. 'rustc' must be installed
       and accessible in the system's PATH.

ARGUMENTS
       FILE.rs
              The path to the Rust source file (.rs) within the VFS.

EXAMPLES
       rust_compile /home/guest/my_app.rs
              Compiles and runs 'my_app.rs'.

SEE ALSO
       python(1), exec(1)

OBPI CLI                                                       RUST_COMPILE(1)
            `,
      haskell_compile: `HASKELL_COMPILE(1)                                                 HASKELL_COMPILE(1)
NAME
       haskell_compile - compile and run Haskell code

SYNOPSIS
       haskell_compile FILE.hs

DESCRIPTION
       This command compiles a Haskell source file from the Virtual File System (VFS)
       and attempts to run the resulting executable.

       It uses the 'Glasgow Haskell Compiler' ('ghc') on the host system. 'ghc' must be installed
       and accessible in the system's PATH.

ARGUMENTS
       FILE.hs
              The path to the Haskell source file (.hs) within the VFS.

EXAMPLES
       haskell_compile /home/guest/my_program.hs
              Compiles and runs 'my_program.hs'.

SEE ALSO
       python(1), exec(1)

OBPI CLI                                                     HASKELL_COMPILE(1)
            `,
      cobol_compile: `COBOL_COMPILE(1)                                                   COBOL_COMPILE(1)
NAME
       cobol_compile - compile and run Cobol code

SYNOPSIS
       cobol_compile FILE.cbl

DESCRIPTION
       This command compiles a Cobol source file from the Virtual File System (VFS)
       and attempts to run the resulting executable.

       It uses the 'GnuCOBOL' compiler ('cobc') on the host system. 'cobc' must be installed
       and accessible in the system's PATH.

ARGUMENTS
       FILE.cbl
              The path to the Cobol source file (.cbl) within the VFS.

EXAMPLES
       cobol_compile /home/guest/my_program.cbl
              Compiles and runs 'my_program.cbl'.

SEE ALSO
       python(1), exec(1)

OBPI CLI                                                     COBOL_COMPILE(1)
            `,
      fortran_compile: `FORTRAN_COMPILE(1)                                                 FORTRAN_COMPILE(1)
NAME
       fortran_compile - compile and run Fortran code

SYNOPSIS
       fortran_compile FILE.f90

DESCRIPTION
       This command compiles a Fortran source file from the Virtual File System (VFS)
       and attempts to run the resulting executable.

       It uses the 'GFortran' compiler ('gfortran') on the host system. 'gfortran' must be installed
       and accessible in the system's PATH.

ARGUMENTS
       FILE.f90
              The path to the Fortran source file (.f90) within the VFS.

EXAMPLES
       fortran_compile /home/guest/my_program.f90
              Compiles and runs 'my_program.f90'.

SEE ALSO
       python(1), exec(1)

OBPI CLI                                                     FORTRAN_COMPILE(1)
            `,
      lua_run: `LUA_RUN(1)                                                         LUA_RUN(1)
NAME
       lua_run - run Lua code

SYNOPSIS
       lua_run FILE.lua

DESCRIPTION
       This command runs a Lua script file from the Virtual File System (VFS).

       It uses the 'Lua interpreter' ('lua') on the host system. 'lua' must be installed
       and accessible in the system's PATH.

ARGUMENTS
       FILE.lua
              The path to the Lua script file (.lua) within the VFS.

EXAMPLES
       lua_run /home/guest/my_script.lua
              Runs 'my_script.lua'.

SEE ALSO
       python(1), exec(1)

OBPI CLI                                                           LUA_RUN(1)
            `,
      emcc_compile: `EMCC_COMPILE(1)                                                    EMCC_COMPILE(1)
NAME
       emcc_compile - conceptually compile C/C++ to WebAssembly/JavaScript

SYNOPSIS
       emcc_compile LANG FILE.c/cpp

DESCRIPTION
       This command conceptually compiles a C or C++ source file from the
       Virtual File System (VFS) into WebAssembly (WASM) and JavaScript.

       It uses the 'Emscripten SDK' ('emcc') on the host system. 'emcc' must be
       installed and accessible in the system's PATH. This command provides a
       conceptual output representing the result of such a compilation.

ARGUMENTS
       LANG
              The source language, either 'c' or 'cpp'.

       FILE.c/cpp
              The path to the C or C++ source file within the VFS.

EXAMPLES
       emcc_compile c /home/guest/my_c_code.c
              Conceptually compiles 'my_c_code.c' to WASM/JS.

SEE ALSO
       hex_to_webgl(1), wasm_test(1)

OBPI CLI                                                       EMCC_COMPILE(1)
            `,
      hex_to_webgl: `HEX_TO_WEBGL(1)                                                    HEX_TO_WEBGL(1)
NAME
       hex_to_webgl - conceptually compile hexadecimal to WebGL binary bytecode

SYNOPSIS
       hex_to_webgl HEX_STRING_OR_FILE

DESCRIPTION
       This command takes a hexadecimal string (or content from a VFS file
       containing hex) and conceptually "compiles" it into WebGL binary bytecode
       and GLSL shaders.

       This is a simulation of a highly complex process. WebGL uses GLSL shaders
       (text-based) and binary buffers (for geometry/textures), not direct
       arbitrary "binary bytecode" from hex. This command demonstrates the concept
       of transforming low-level data into a format usable by WebGL.

ARGUMENTS
       HEX_STRING_OR_FILE
              The hexadecimal string directly, or a path to a VFS file
              containing the hexadecimal string.

EXAMPLES
       hex_to_webgl "48656C6C6F"
              Conceptually compiles the hex for "Hello" to WebGL bytecode.

       hex_to_webgl /home/guest/my_hex_data.txt
              Reads hex from 'my_hex_data.txt' and conceptually compiles it.

SEE ALSO
       emcc_compile(1), wasm_test(1)

OBPI CLI                                                       HEX_TO_WEBGL(1)
            `,
      // Add more man pages here for other commands as needed
    },
    apps: {
      encapsulatedBrowser: {
        iframe: null, urlInput: null,
        init: (initialUrl = 'https://duckduckgo.com') => {
          const content = document.createElement('div');
          content.className = 'w-full h-full flex flex-col bg-white';

          const searchBarContainer = document.createElement('div');
          searchBarContainer.id = 'web-view-search-bar';
          searchBarContainer.innerHTML = `
                        <button class="back-btn nav-btn" title="Back">←</button>
                        <button class="fwd-btn nav-btn" title="Forward">→</button>
                        <button class="refresh-btn nav-btn" title="Refresh">↻</button>
                        <input type="text" class="url-input" placeholder="Enter URL or search query...">
                        <button class="go-btn">Go</button>
                        <button class="history-btn nav-btn" title="History">📜</button>
                        <button class="bookmarks-btn nav-btn" title="Bookmarks">⭐</button>
                        <button class="add-bookmark-btn nav-btn" title="Add Bookmark">➕</button>
                    `;

          AppManager.apps.encapsulatedBrowser.urlInput = searchBarContainer.querySelector('.url-input');
          AppManager.apps.encapsulatedBrowser.iframe = document.createElement('iframe');
          AppManager.apps.encapsulatedBrowser.iframe.id = 'web-view-iframe';
          AppManager.apps.encapsulatedBrowser.iframe.sandbox = "allow-forms allow-modals allow-pointer-lock allow-popups allow-presentation allow-same-origin allow-scripts";

          const goAction = () => {
            let query = AppManager.apps.encapsulatedBrowser.urlInput.value.trim();
            if (!query.startsWith('http://') && !query.startsWith('https://')) {
              if (query.includes('.')) { // Simple check for domain-like input
                query = 'https://' + query;
              } else { // Assume search query
                query = `https://duckduckgo.com/?q=${encodeURIComponent(query)}`;
              }
            }
            AppManager.apps.encapsulatedBrowser.iframe.src = query;
            // Add to history after navigation
            AppManager.apps.encapsulatedBrowser.addHistory(query, query); // Title will be updated by iframe onload
          };

          AppManager.apps.encapsulatedBrowser.iframe.onload = async () => {
            try {
              const currentUrl = AppManager.apps.encapsulatedBrowser.iframe.contentWindow.location.href;
              const currentTitle = AppManager.apps.encapsulatedBrowser.iframe.contentDocument.title || currentUrl;
              // Update history with correct title after page loads
              await window.pywebview.api.add_browser_history_backend(currentUrl, currentTitle);
              OBPI.kernel.log(`Browser: Loaded ${currentTitle} (${currentUrl})`, 'info');
            } catch (e) {
              OBPI.kernel.log(`Browser: Could not get iframe content details: ${e.message}`, 'warn');
            }
          };

          if (initialUrl) {
            AppManager.apps.encapsulatedBrowser.urlInput.value = initialUrl;
            AppManager.apps.encapsulatedBrowser.iframe.src = initialUrl;
            AppManager.apps.encapsulatedBrowser.addHistory(initialUrl, initialUrl);
          }

          searchBarContainer.querySelector('.back-btn').onclick = () => { try {AppManager.apps.encapsulatedBrowser.iframe.contentWindow.history.back();} catch(e){OBPI.kernel.log("Browser back failed.", "warn");} };
          searchBarContainer.querySelector('.fwd-btn').onclick = () => { try {AppManager.apps.encapsulatedBrowser.iframe.contentWindow.history.forward();} catch(e){OBPI.kernel.log("Browser forward failed.", "warn");} };
          searchBarContainer.querySelector('.refresh-btn').onclick = () => { try {AppManager.apps.encapsulatedBrowser.iframe.contentWindow.location.reload();} catch(e){OBPI.kernel.log("Browser refresh failed.", "warn");} };
          searchBarContainer.querySelector('.go-btn').onclick = goAction;
          AppManager.apps.encapsulatedBrowser.urlInput.onkeypress = (e) => { if (e.key === 'Enter') goAction(); };

          searchBarContainer.querySelector('.history-btn').onclick = () => AppManager.apps.encapsulatedBrowser.showHistory();
          searchBarContainer.querySelector('.bookmarks-btn').onclick = () => AppManager.apps.encapsulatedBrowser.showBookmarks();
          searchBarContainer.querySelector('.add-bookmark-btn').onclick = () => AppManager.apps.encapsulatedBrowser.addBookmark();

          content.appendChild(searchBarContainer);
          content.appendChild(AppManager.apps.encapsulatedBrowser.iframe);
          return content;
        },
        addHistory: async (url, title) => {
          const response = await window.pywebview.api.add_browser_history_backend(url, title);
          if (response.error) {
            OBPI.kernel.log(`Failed to add history: ${response.error}`, 'error');
          }
        },
        showHistory: async () => {
          const response = await window.pywebview.api.get_browser_history_backend();
          if (response.error) {
            Modal.show("Browser History Error", `Failed to load history: ${response.error}`);
            return;
          }
          const history = response.history || [];
          let historyHtml = '<h4 class="font-semibold mb-2">Recent History:</h4><ul class="browser-history-list">';
          if (history.length === 0) {
            historyHtml += '<li>No history found.</li>';
          } else {
            history.forEach(item => {
              historyHtml += `<li class="browser-history-item" data-url="${item.url}" title="${item.url}">
                                <strong>${item.title}</strong><br>
                                <span class="url">${item.url}</span><br>
                                <span class="timestamp text-xs text-gray-500">${new Date(item.timestamp).toLocaleString()}</span>
                            </li>`;
            });
          }
          historyHtml += '</ul>';
          Modal.show("Browser History", historyHtml, [{text: 'Close'}]);

          // Add click listeners to history items
          document.querySelectorAll('.browser-history-item').forEach(item => {
            item.onclick = (e) => {
              const url = e.currentTarget.dataset.url;
              if (url) {
                AppManager.apps.encapsulatedBrowser.urlInput.value = url;
                AppManager.apps.encapsulatedBrowser.iframe.src = url;
                Modal.hide();
              }
            };
          });
        },
        addBookmark: async () => {
          const currentUrl = AppManager.apps.encapsulatedBrowser.iframe.contentWindow.location.href;
          const currentTitle = AppManager.apps.encapsulatedBrowser.iframe.contentDocument.title || currentUrl;
          Modal.prompt('Add Bookmark', 'Enter bookmark title:', currentTitle, async (title) => {
            if (title) {
              const response = await window.pywebview.api.add_browser_bookmark_backend(currentUrl, title);
              if (response.error) {
                Modal.show("Add Bookmark Error", `Failed to add bookmark: ${response.error}`);
              } else {
                Modal.show("Bookmark Added", `Bookmark "${title}" added successfully!`);
              }
            }
          });
        },
        showBookmarks: async () => {
          const response = await window.pywebview.api.get_browser_bookmarks_backend();
          if (response.error) {
            Modal.show("Browser Bookmarks Error", `Failed to load bookmarks: ${response.error}`);
            return;
          }
          const bookmarks = response.bookmarks || [];
          let bookmarksHtml = '<h4 class="font-semibold mb-2">Your Bookmarks:</h4><ul class="browser-bookmarks-list">';
          if (bookmarks.length === 0) {
            bookmarksHtml += '<li>No bookmarks found.</li>';
          } else {
            bookmarks.forEach(item => {
              bookmarksHtml += `<li class="browser-bookmark-item" data-url="${item.url}" title="${item.url}">
                                <strong>${item.title}</strong>
                                <span class="delete-btn" data-url="${item.url}">🗑️</span><br>
                                <span class="url">${item.url}</span>
                            </li>`;
            });
          }
          bookmarksHtml += '</ul>';
          Modal.show("Browser Bookmarks", bookmarksHtml, [{text: 'Close'}]);

          // Add click listeners to bookmark items
          document.querySelectorAll('.browser-bookmark-item').forEach(item => {
            item.querySelector('strong').onclick = (e) => {
              const url = e.currentTarget.closest('.browser-bookmark-item').dataset.url;
              if (url) {
                AppManager.apps.encapsulatedBrowser.urlInput.value = url;
                AppManager.apps.encapsulatedBrowser.iframe.src = url;
                Modal.hide();
              }
            };
            item.querySelector('.delete-btn').onclick = async (e) => {
              e.stopPropagation(); // Prevent parent li click
              const urlToDelete = e.currentTarget.dataset.url;
              Modal.confirm("Delete Bookmark", `Are you sure you want to delete this bookmark?`, async (confirmed) => {
                if (confirmed) {
                  const deleteResponse = await window.pywebview.api.delete_browser_bookmark_backend(urlToDelete);
                  if (deleteResponse.error) {
                    Modal.show("Delete Bookmark Error", `Failed to delete bookmark: ${deleteResponse.error}`);
                  } else {
                    Modal.show("Bookmark Deleted", `Bookmark deleted successfully.`);
                    AppManager.apps.encapsulatedBrowser.showBookmarks(); // Refresh bookmarks list
                  }
                }
              });
            };
          });
        }
      },
      dechexIDE: {
        init: () => { const content = document.createElement('div'); content.className = 'p-3 cli-font h-full flex flex-col'; content.innerHTML = `<h3 class="text-lg font-semibold mb-2 text-gray-800">DecHex Language IDE v0.3</h3> <p class="text-xs mb-2 text-gray-600">Opcodes: 0A=ADD, 0B=SUB, 0C=PRINT_ACC, 0D=LOAD, 0E=PUSH, 0F=POP, 10=PEEK_STACK, 11=JMP_IF_ZERO(addr), 12=STORE_ACC(addr), 13=LOAD_ACC(addr)</p> <textarea class="code-area w-full p-2 border rounded mb-2 bg-gray-50 text-sm flex-grow" rows="8" placeholder="e.g., 0D05 0E 0D0A 0A01 0E 0F 0C"></textarea> <button class="run-btn px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 self-start mb-2">Run Code</button> <pre class="output-area w-full p-2 border rounded bg-gray-800 text-green-300 flex-grow overflow-auto text-xs">Output...</pre>`; const codeArea = content.querySelector('.code-area'); const outputArea = content.querySelector('.output-area'); content.querySelector('.run-btn').onclick = () => { try { outputArea.textContent = DecHexLang.interpret(codeArea.value); } catch (e) { outputArea.textContent = `Error: ${e.message}`; } }; return content; }
      },
      aiAssistant: {
        chatOutputElement: null, inputElement: null, speechSynth: window.speechSynthesis,
        init: () => {
          const content = document.createElement('div');
          content.className = 'w-full h-full flex flex-col';

          // Tabs for Chat and Hex Converter
          const tabsContainer = document.createElement('div');
          tabsContainer.className = 'ai-tabs';
          tabsContainer.innerHTML = `
                        <button id="ai-chat-tab-btn" class="ai-tab-button active">Chat</button>
                        <button id="ai-hex-tab-btn" class="ai-tab-button">Hex Converter</button>
                        <button id="ai-voice-toggle-btn" class="ai-tab-button ml-auto"> Voice Off</button>
                    `;
          content.appendChild(tabsContainer);

          // Chat Tab Content
          const chatTabContent = document.createElement('div');
          chatTabContent.id = 'ai-chat-tab-content';
          chatTabContent.className = 'ai-tab-content active';
          AppManager.apps.aiAssistant.chatOutputElement = document.createElement('div');
          AppManager.apps.aiAssistant.chatOutputElement.id = 'ai-chat-output';
          const chatInputArea = document.createElement('div');
          chatInputArea.id = 'ai-input-area';
          AppManager.apps.aiAssistant.inputElement = document.createElement('input');
          AppManager.apps.aiAssistant.inputElement.type = 'text';
          AppManager.apps.aiAssistant.inputElement.id = 'ai-input';
          AppManager.apps.aiAssistant.inputElement.placeholder = 'Ask the assistant...';
          AppManager.apps.aiAssistant.inputElement.onkeypress = (e) => {
            if (e.key === 'Enter' && AppManager.apps.aiAssistant.inputElement.value.trim()) {
              AppManager.apps.aiAssistant.handleQuery(AppManager.apps.aiAssistant.inputElement.value.trim());
              AppManager.apps.aiAssistant.inputElement.value = '';
            }
          };
          const sendButton = document.createElement('button');
          sendButton.id = 'ai-send-button';
          sendButton.textContent = 'Send';
          sendButton.onclick = () => {
            if (AppManager.apps.aiAssistant.inputElement.value.trim()) {
              AppManager.apps.aiAssistant.handleQuery(AppManager.apps.aiAssistant.inputElement.value.trim());
              AppManager.apps.aiAssistant.inputElement.value = '';
            }
          };
          chatInputArea.appendChild(AppManager.apps.aiAssistant.inputElement);
          chatInputArea.appendChild(sendButton);
          chatTabContent.appendChild(AppManager.apps.aiAssistant.chatOutputElement);
          chatTabContent.appendChild(chatInputArea);
          content.appendChild(chatTabContent);

          // Hex Converter Tab Content
          const hexConverterTabContent = document.createElement('div');
          hexConverterTabContent.id = 'ai-hex-tab-content';
          hexConverterTabContent.className = 'ai-tab-content';
          hexConverterTabContent.innerHTML = `
                        <h4 class="font-semibold mb-2">Text to Hex:</h4>
                        <textarea id="text-to-hex-input" placeholder="Enter text to convert to hex..."></textarea>
                        <button id="convert-to-hex-btn">Convert to Hex</button>
                        <h4 class="font-semibold mt-4 mb-2">Hex to Text:</h4>
                        <textarea id="hex-to-text-input" placeholder="Enter hex string to convert to text..."></textarea>
                        <button id="convert-to-text-btn">Convert to Text</button>
                        <h4 class="font-semibold mt-4 mb-2">Output:</h4>
                        <pre id="hex-converter-output"></pre>
                    `;
          content.appendChild(hexConverterTabContent);

          // Event Listeners for Tabs
          tabsContainer.querySelector('#ai-chat-tab-btn').onclick = () => AppManager.apps.aiAssistant.showTab('chat');
          tabsContainer.querySelector('#ai-hex-tab-btn').onclick = () => AppManager.apps.aiAssistant.showTab('hex');
          tabsContainer.querySelector('#ai-voice-toggle-btn').onclick = (e) => AppManager.apps.aiAssistant.toggleVoice(e.target);

          // Event Listeners for Hex Converter
          hexConverterTabContent.querySelector('#convert-to-hex-btn').onclick = () => AppManager.apps.aiAssistant.convertTextToHex();
          hexConverterTabContent.querySelector('#convert-to-text-btn').onclick = () => AppManager.apps.aiAssistant.convertHexToText();

          AppManager.apps.aiAssistant.addMessage("AI Assistant v1.0 ready. Try asking me to 'convert C print hello to hex'.", 'assistant');
          return content;
        },
        addMessage: (text, sender) => {
          if (!AppManager.apps.aiAssistant.chatOutputElement) return;
          const msgDiv = document.createElement('div');
          msgDiv.classList.add('ai-message', sender);
          msgDiv.textContent = text;
          AppManager.apps.aiAssistant.chatOutputElement.appendChild(msgDiv);
          AppManager.apps.aiAssistant.chatOutputElement.scrollTop = AppManager.apps.aiAssistant.chatOutputElement.scrollHeight;
          if (sender === 'assistant' && AppManager.apps.aiAssistant.voiceEnabled) {
            AppManager.apps.aiAssistant.speak(text);
          }
        },
        handleQuery: async (query) => {
          AppManager.apps.aiAssistant.addMessage(query, 'user');
          let response = "Processing your request...";
          AppManager.apps.aiAssistant.addMessage(response, 'assistant'); // Immediate feedback

          try {
            const backendResponse = await window.pywebview.api.assistant_process_query(query);
            if (backendResponse.error) {
              response = `Error from assistant backend: ${backendResponse.error}`;
              AppManager.apps.aiAssistant.updateLastAssistantMessage(response);
            } else {
              // The backendResponse is now the full object from assist.py
              let assistantText = backendResponse.response_text;
              if (backendResponse.generated_hex) {
                assistantText += `\n\nGenerated ${backendResponse.language.toUpperCase()} Hex:\n${backendResponse.generated_hex}`;
                // For display, decode it back to ASCII if it's not a comment
                const decoded = AppManager.apps.aiAssistant.jsHexDecoder.hexToString(backendResponse.generated_hex.split('\n')[0].replace('// ', ''));
                if (decoded && decoded.length > 0) {
                  assistantText += `\nDecoded ASCII: "${decoded}"`;
                }
              }
              AppManager.apps.aiAssistant.updateLastAssistantMessage(assistantText);
            }
          } catch (e) {
            response = `Communication error with assistant backend: ${e.message}`;
            AppManager.apps.aiAssistant.updateLastAssistantMessage(response);
            OBPI.kernel.log(`AI Assistant backend call error: ${e.stack}`, 'error');
          }
        },
        updateLastAssistantMessage: (newText) => {
          if (!AppManager.apps.aiAssistant.chatOutputElement) return;
          const messages = AppManager.apps.aiAssistant.chatOutputElement.querySelectorAll('.ai-message.assistant');
          if (messages.length > 0) {
            messages[messages.length - 1].textContent = newText;
            AppManager.apps.aiAssistant.chatOutputElement.scrollTop = AppManager.apps.aiAssistant.chatOutputElement.scrollHeight;
            if (AppManager.apps.aiAssistant.voiceEnabled) {
              AppManager.apps.aiAssistant.speak(newText);
            }
          }
        },
        speak: (text) => {
          if (AppManager.apps.aiAssistant.speechSynth.speaking) {
            AppManager.apps.aiAssistant.speechSynth.cancel();
          }
          const utterance = new SpeechSynthesisUtterance(text);
          const voices = AppManager.apps.aiAssistant.speechSynth.getVoices();
          const preferredVoice = voices.find(voice =>
            voice.lang.startsWith('en') &&
            (voice.name.includes('Google') || voice.name.includes('Microsoft') || voice.name.includes('Zira') || voice.name.includes('David'))
          );
          if (preferredVoice) {
            utterance.voice = preferredVoice;
          }
          AppManager.apps.aiAssistant.speechSynth.speak(utterance);
        },
        voiceEnabled: false, // Default to off
        toggleVoice: (button) => {
          AppManager.apps.aiAssistant.voiceEnabled = !AppManager.apps.aiAssistant.voiceEnabled;
          if (AppManager.apps.aiAssistant.voiceEnabled) {
            button.textContent = " Voice On";
            AppManager.apps.aiAssistant.speak("Voice activated.");
          } else {
            button.textContent = " Voice Off";
            AppManager.apps.aiAssistant.speechSynth.cancel(); // Stop any ongoing speech
          }
        },
        showTab: (tabId) => {
          document.querySelectorAll('.ai-tab-button').forEach(btn => btn.classList.remove('active'));
          document.querySelectorAll('.ai-tab-content').forEach(content => content.classList.remove('active'));

          document.getElementById(`ai-${tabId}-tab-btn`).classList.add('active');
          document.getElementById(`ai-${tabId}-tab-content`).classList.add('active');
        },
        convertTextToHex: async () => {
          const inputText = document.getElementById('text-to-hex-input').value;
          const outputArea = document.getElementById('hex-converter-output');
          if (!inputText) {
            outputArea.textContent = "Please enter text to convert.";
            return;
          }
          try {
            const response = await window.pywebview.api.assistant_text_to_hex(inputText);
            if (response.error) {
              outputArea.textContent = `Error converting to hex: ${response.error}`;
            } else {
              outputArea.textContent = `Hexadecimal: ${response.hex_output}`;
            }
          } catch (e) {
            outputArea.textContent = `Backend communication error: ${e.message}`;
          }
        },
        convertHexToText: async () => {
          const inputHex = document.getElementById('hex-to-text-input').value;
          const outputArea = document.getElementById('hex-converter-output');
          if (!inputHex) {
            outputArea.textContent = "Please enter hex to convert.";
            return;
          }
          try {
            const response = await window.pywebview.api.assistant_hex_to_text(inputHex);
            if (response.error) {
              outputArea.textContent = `Error converting to text: ${response.error}`;
            } else {
              outputArea.textContent = `Decoded Text: ${response.text_output}`;
            }
          } catch (e) {
            outputArea.textContent = `Backend communication error: ${e.message}`;
          }
        },
        // JS Hex Decoder (client-side for quick operations if needed)
        jsHexDecoder: {
          stringToHex: (s) => {
            return Array.from(s).map(char => {
              return char.charCodeAt(0).toString(16).padStart(2, '0');
            }).join('');
          },
          hexToString: (h) => {
            try {
              const hex = h.toString();
              let str = '';
              for (let i = 0; i < hex.length; i += 2) {
                str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
              }
              return str;
            } catch (e) {
              return `Error decoding hex: ${e.message}`;
            }
          }
        }
      },
      diskManager: {
        init: () => { const content = document.createElement('div'); content.id = 'disk-manager-content'; content.innerHTML = `<h3 class="text-lg font-semibold mb-3">Virtual Disk Management (VFS)</h3>`; const createVolButton = document.createElement('button'); createVolButton.textContent = 'Create New Virtual Volume'; createVolButton.className = 'px-3 py-1.5 bg-green-500 text-white rounded hover:bg-green-600 text-sm mb-3'; createVolButton.onclick = () => { Modal.prompt('Create Volume', 'Enter volume name (e.g., my_data):', 'new_volume', async (name) => { if (name) { const newDirPath = `/${name}`; const response = await window.pywebview.api.create_directory_backend(newDirPath); if (response.error) { Modal.show('Error', `Failed to create volume: ${response.error}`, [{text:'OK'}]); } else { // Also create a dummy info.txt file in the new volume await window.pywebview.api.write_file_backend(`${newDirPath}/info.txt`, `Virtual Volume '${name}' created on ${new Date().toLocaleString()}`); AppManager.apps.diskManager.renderVolumes(content); Terminal.print(`Virtual volume '${name}' created at root.`, false, 'success'); } } }); }; content.appendChild(createVolButton); AppManager.apps.diskManager.renderVolumes(content); return content; },
          renderVolumes: async (container) => {
            let volumesList = container.querySelector('.volumes-list');
            if (!volumesList) { volumesList = document.createElement('div'); volumesList.className = 'volumes-list mt-2'; container.appendChild(volumesList); }
            volumesList.innerHTML = '';
            const response = await window.pywebview.api.list_directory_backend('/');
            if (response.error) {
              volumesList.innerHTML = `<p class="text-red-500">Error loading volumes: ${response.error}</p>`;
              return;
            }
            const rootContents = response.contents || [];

            rootContents.forEach(item => {
              if (item.type === 'dir') {
                const volDiv = document.createElement('div');
                volDiv.className = 'volume-item';
                volDiv.innerHTML = `<strong>${item.name}/</strong> (Virtual Volume) <button data-volname="${item.name}" class="delete-vol-btn text-xs text-red-500 hover:text-red-700 ml-2 p-1">Delete</button>`;
                volumesList.appendChild(volDiv);
              }
            });
            volumesList.querySelectorAll('.delete-vol-btn').forEach(btn => {
              btn.onclick = (e) => {
                const volName = e.target.dataset.volname;
                Modal.confirm('Delete Volume', `Are you sure you want to delete the virtual volume '${volName}' and all its contents? This cannot be undone.`, async (confirmed) => {
                  if (confirmed) {
                    const response = await window.pywebview.api.delete_path_backend(`/${volName}`, true); // Recursive delete
                    if (response.error) {
                      Modal.show('Error', `Failed to delete volume: ${response.error}`, [{text:'OK'}]);
                    } else {
                      AppManager.apps.diskManager.renderVolumes(container);
                      Terminal.print(`Virtual volume '${volName}' deleted.`, false, 'warn');
                    }
                  }
                });
              };
            });
          }
        },
          ncursesApp: {
            init: () => {
              const content = document.createElement('div');
              content.id = 'ncurses-display-area';
              content.style.cssText = 'width:100%; height:100%; display:grid; grid-template-columns: repeat(var(--cols, 80), 1fr); grid-template-rows: repeat(var(--rows, 24), 1fr); font-size: 14px; line-height: 1.1;';
              content.style.setProperty('--cols', 80);
              content.style.setProperty('--rows', 24);

              // Ncurses content generation (expanded)
              const rows = 24;
              const cols = 80;
              const buffer = Array(rows).fill(0).map(() => Array(cols).fill(' '));

              // Draw border
              for(let c = 0; c < cols; c++) { buffer[0][c] = buffer[rows-1][c] = '-'; }
              for(let r = 0; r < rows; r++) { buffer[r][0] = buffer[r][cols-1] = '|'; }
              buffer[0][0] = buffer[0][cols-1] = buffer[rows-1][0] = buffer[rows-1][cols-1] = '+';

              // Title
              const title = "Ncurses Demo App (v1.0)";
              const titleStart = Math.floor((cols - title.length) / 2);
              for(let i = 0; i < title.length; i++) { buffer[2][titleStart + i] = title[i]; }

              // Dynamic content example
              const message = "Hello from OBPI!";
              const timeStr = new Date().toLocaleTimeString();
              const dateStr = new Date().toLocaleDateString();

              const putString = (r, c, s) => {
                for(let i = 0; i < s.length; i++) {
                  if (c + i < cols - 1) buffer[r][c + i] = s[i];
                }
              };

              putString(5, 5, message);
              putString(7, 5, `Current Time: ${timeStr}`);
              putString(8, 5, `Current Date: ${dateStr}`);
              putString(10, 5, "Type 'exit' to close this window.");
              putString(12, 5, "This is now an integrated CLI package!");

              // Render buffer to DOM
              for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                  const charCell = document.createElement('span');
                  charCell.className = 'ncurses-char';
                  charCell.textContent = buffer[r][c];
                  content.appendChild(charCell);
                }
              }
              return content;
            }
          },
          wasmCoreTest: {
            run: async () => { Terminal.print("Running WASM Core Test...", false, 'info'); try { const coreModule = await OBPI.kernel.loadWasmModule('conceptual/core_emulator.wasm'); if (coreModule && coreModule.add_native && coreModule.get_native_greeting) { const sum = coreModule.add_native(15, 27); Terminal.print(`WASM: add_native(15, 27) = ${sum}`, false, 'success'); const greeting = coreModule.get_native_greeting("OBPI User"); Terminal.print(`WASM: ${greeting}`, false, 'success'); const ts = coreModule.get_system_timestamp_native(); Terminal.print(`WASM: get_system_timestamp_native() = ${ts} (Unix Timestamp)`, false, 'success'); } else { Terminal.print("WASM core module or its functions not found (simulated).", false, 'error'); } } catch (e) { Terminal.print(`WASM Core Test Error: ${e.message}`, false, 'error'); } }
          },
          xmlParserTest: {
            run: () => { const xmlString = `<note><to>User</to><from>OBPI</from><heading>Reminder</heading><body>Test XML Parsing!</body></note>`; Terminal.print(`Parsing XML: ${xmlString.replace(/</g, "&lt;")}`, false, 'info'); try { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "text/xml"); const parserError = xmlDoc.getElementsByTagName("parsererror"); if (parserError.length > 0) throw new Error("XML parsing error: " + parserError[0].textContent); const to = xmlDoc.getElementsByTagName("to")[0]?.childNodes[0]?.nodeValue; const body = xmlDoc.getElementsByTagName("body")[0]?.childNodes[0]?.nodeValue; Terminal.print(`XML Parsed: To='${to}', Body='${body}'`, false, 'success'); } catch (e) { Terminal.print(`XML Parsing Error: ${e.message}`, false, 'error'); } }
          },
                                                                                                                                      </hex_string_or_file_path>
          pythonRunner: {
            codeArea: null, outputArea: null,
              init: () => { const content = document.createElement('div'); const title = document.createElement('h3'); title.textContent = 'Python Runner'; title.className = 'text-lg font-semibold mb-2 text-gray-800'; AppManager.apps.pythonRunner.codeArea = document.createElement('textarea'); AppManager.apps.pythonRunner.codeArea.id = 'python-code-area'; AppManager.apps.pythonRunner.codeArea.placeholder = '# Enter Python code here\nprint("Hello from OBPI Python Runner!")'; AppManager.apps.pythonRunner.codeArea.value = 'import datetime\n\nprint(f"Hello from Python Runner! The current time is {datetime.datetime.now()}")'; const runButton = document.createElement('button'); runButton.textContent = 'Run Python Code'; runButton.className = 'px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 self-start my-2'; runButton.onclick = () => AppManager.apps.pythonRunner.runCode(); AppManager.apps.pythonRunner.outputArea = document.createElement('div'); AppManager.apps.pythonRunner.outputArea.id = 'python-output-area'; AppManager.apps.pythonRunner.outputArea.textContent = 'Python output will appear here...'; content.appendChild(title); content.appendChild(AppManager.apps.pythonRunner.codeArea); content.appendChild(runButton); content.appendChild(AppManager.apps.pythonRunner.outputArea); return content; },
              runCode: async (codeToRun) => {
              const code = codeToRun || AppManager.apps.pythonRunner.codeArea.value;
              if (!code) { if(AppManager.apps.pythonRunner.outputArea) AppManager.apps.pythonRunner.outputArea.textContent = 'No Python code to run.'; return; }
              if(AppManager.apps.pythonRunner.outputArea) AppManager.apps.pythonRunner.outputArea.textContent = 'Executing Python via backend...\n';
              const response = await window.pywebview.api.execute_python_code(code);
              AppManager.apps.pythonRunner.logOutput(response.output, response.status === 'error');
              if (response.status === 'error') {
                OBPI.kernel.log(`Python Runner Error: ${response.output}`, 'error');
              }
            },
              logOutput: (message, isError = false) => {
              if (AppManager.apps.pythonRunner.outputArea) {
                const entry = document.createElement('div');
                entry.textContent = message;
                if(isError) entry.style.color = 'red';
                AppManager.apps.pythonRunner.outputArea.appendChild(entry);
                AppManager.apps.pythonRunner.outputArea.scrollTop = AppManager.apps.pythonRunner.outputArea.scrollHeight;
              }
              if(Terminal && Terminal.print) Terminal.print(`Python Runner> ${message.trim()}`, false, isError ? 'error' : 'info');
            }
          },
          pyIDE: {
            currentFilePath: null, codeAreaElement:null, outputAreaElement:null, currentFileDisplay:null,
              init: () => { const content = document.createElement('div'); content.className = 'p-1 h-full flex flex-col'; const menuBar = document.createElement('div'); menuBar.className = 'flex gap-2 mb-2 p-1 border-b'; menuBar.innerHTML = ` <button class="save-btn px-2 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600">Save</button> <button class="open-btn px-2 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600">Open</button> <span class="current-file-display text-xs italic self-center ml-auto">No file open</span> `; const codeArea = document.createElement('textarea'); codeArea.id = 'pyide-code-area'; codeArea.value = '# Python IDE - New File\nprint("Hello from OBPI PyIDE")'; const outputArea = document.createElement('div'); outputArea.id = 'pyide-output-area'; outputArea.textContent = 'Python output...'; const runBtn = document.createElement('button'); runBtn.textContent = 'Run in PyIDE'; runBtn.className = 'px-3 py-1.5 bg-green-600 text-white rounded hover:bg-green-700 self-start mt-2 text-sm'; content.appendChild(menuBar); content.appendChild(codeArea); content.appendChild(outputArea); content.appendChild(runBtn); AppManager.apps.pyIDE.codeAreaElement = codeArea; AppManager.apps.pyIDE.outputAreaElement = outputArea; AppManager.apps.pyIDE.currentFileDisplay = menuBar.querySelector('.current-file-display'); menuBar.querySelector('.save-btn').onclick = AppManager.apps.pyIDE.saveFile; menuBar.querySelector('.open-btn').onclick = AppManager.apps.pyIDE.openFile; runBtn.onclick = () => AppManager.apps.pyIDE.runCurrentCode(); return content; },
              updateFileDisplay: () => { if (AppManager.apps.pyIDE.currentFileDisplay) AppManager.apps.pyIDE.currentFileDisplay.textContent = AppManager.apps.pyIDE.currentFilePath || 'Unsaved File'; },
              saveFile: async () => {
              const currentCode = AppManager.apps.pyIDE.codeAreaElement.value;
              const defaultName = AppManager.apps.pyIDE.currentFilePath ? AppManager.apps.pyIDE.currentFilePath.split('/').pop() : 'new_script.py';
              Modal.prompt('Save Python Script', 'Enter filename (e.g., script.py):', defaultName, async (filename) => { // Made async
                if (filename) {
                  const savePath = filename.startsWith('/') ? filename : OBPI.currentPath + filename;
                  const response = await window.pywebview.api.write_file_backend(savePath, currentCode);
                  if (response.error) {
                    Modal.show('Error', `Failed to save file: ${response.error}`);
                  } else {
                    AppManager.apps.pyIDE.currentFilePath = savePath;
                    AppManager.apps.pyIDE.updateFileDisplay();
                    Terminal.print(`PyIDE: Saved to ${savePath}`, false, 'success');
                  }
                }
              });
            },
              openFile: () => {
              Modal.prompt('Open Python Script', 'Enter path to file (e.g., /home/guest/python_scripts/hello.py):', OBPI.currentPath, async (filePath) => { // Made async
                if (filePath) {
                  const response = await window.pywebview.api.get_file_content_backend(filePath);
                  if (response.error) {
                    Modal.show('Error', `Could not open file: ${response.error}`);
                    AppManager.apps.pyIDE.outputAreaElement.textContent = `Error opening ${filePath}: ${response.error}`;
                  } else {
                    AppManager.apps.pyIDE.codeAreaElement.value = response.content;
                    AppManager.apps.pyIDE.currentFilePath = filePath;
                    AppManager.apps.pyIDE.updateFileDisplay();
                    AppManager.apps.pyIDE.outputAreaElement.textContent = `Opened ${filePath}`;
                  }
                }
              });
            },
              runCurrentCode: async () => {
              const code = AppManager.apps.pyIDE.codeAreaElement.value;
              if (AppManager.apps.pyIDE.outputAreaElement) AppManager.apps.pyIDE.outputAreaElement.textContent = 'Executing Python...\n';
              const response = await window.pywebview.api.execute_python_code(code);
              AppManager.apps.pyIDE.logOutput(response.output, response.status === 'error');
            },
              logOutput: (message, isError = false) => {
              if (AppManager.apps.pyIDE.outputAreaElement) {
                const entry = document.createElement('span');
                entry.textContent = message;
                if(isError) entry.style.color = '#ff6b6b';
                else entry.style.color = '#90ee90';
                AppManager.apps.pyIDE.outputAreaElement.appendChild(entry);
                AppManager.apps.pyIDE.outputAreaElement.scrollTop = AppManager.apps.pyIDE.outputAreaElement.scrollHeight;
              }
            }
          },
          networkManager: {
            simulatedNetworks: [
              { ssid: "OBPI_WiFi_Guest", signal: 85, security: "WPA2" },
              { ssid: "CoffeeShop_Free", signal: 60, security: "Open" },
              { ssid: "MyHomeNet_5G", signal: 95, security: "WPA3" },
              { ssid: "Public_Hotspot", signal: 40, security: "Open" },
              { ssid: "Enterprise_WLAN", signal: 70, security: "WPA2-EAP" }
            ],
              init: () => { const content = document.createElement('div'); content.innerHTML = `<h3 class="text-lg font-semibold mb-3">Network Manager (Simulated)</h3> <button class="scan-btn px-3 py-1.5 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm mb-3">Scan for Networks</button> <ul class="network-list"></ul>`; content.querySelector('.scan-btn').onclick = async () => { const hasPerm = await OBPI.kernel.requestPermission('network_scan', 'NetworkManagerApp'); if(hasPerm) AppManager.apps.networkManager.renderNetworks(content); else Modal.show("Permission Denied", "Network scan permission was not granted."); }; return content; },
              getSimulatedNetworks: () => {
              return AppManager.apps.networkManager.simulatedNetworks.map(net => ({
                ...net,
                signal: Math.max(20, Math.min(100, net.signal + Math.floor(Math.random() * 20) - 10))
              }));
            },
              renderNetworks: (container) => {
              const list = container.querySelector('.network-list');
              list.innerHTML = 'Scanning...';
              setTimeout(() => {
                list.innerHTML = '';
                const networks = AppManager.apps.networkManager.getSimulatedNetworks();
                if (networks.length === 0) {
                  list.innerHTML = '<li>No networks found.</li>';
                  return;
                }
                networks.forEach(net => {
                  const item = document.createElement('li');
                  item.innerHTML = `<span>${net.ssid} (Signal: ${net.signal}%, Security: ${net.security})</span> <button data-ssid="${net.ssid}" class="connect-btn px-2 py-0.5 bg-green-500 text-white text-xs rounded hover:bg-green-600">Connect</button>`;
                  item.querySelector('.connect-btn').onclick = async (e) => {
                    const ssid = e.target.dataset.ssid;
                    const hasPerm = await OBPI.kernel.requestPermission('network_connect', 'NetworkManagerApp');
                    if(hasPerm) AppManager.cliCommands.net(['connect', ssid]);
                    else Modal.show("Permission Denied", "Network connect permission was not granted.");
                  };
                  list.appendChild(item);
                });
              }, 1000);
            }
          },
          bluetoothManager: {
            simulatedDevices: [
              { name: "MyPhone_BT", type: "Phone", battery: 75, connected: false },
              { name: "WirelessHeadphones", type: "Audio", battery: 90, connected: false },
              { name: "SmartWatchX", type: "Watch", battery: 60, connected: true },
              { name: "OBPI_Keyboard", type: "Input", battery: 80, connected: true }
            ],
              init: () => { const content = document.createElement('div'); content.innerHTML = `<h3 class="text-lg font-semibold mb-3">Bluetooth Manager (Simulated)</h3> <button class="scan-btn px-3 py-1.5 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm mb-3">Scan for Devices</button> <ul class="device-list"></ul>`; content.querySelector('.scan-btn').onclick = async () => { const hasPerm = await OBPI.kernel.requestPermission('bluetooth_scan', 'BluetoothManagerApp'); if(hasPerm) AppManager.apps.bluetoothManager.renderDevices(content); else Modal.show("Permission Denied", "Bluetooth scan permission was not granted."); }; return content; },
              getSimulatedDevices: () => {
              return AppManager.apps.bluetoothManager.simulatedDevices.map(dev => ({
                ...dev,
                connected: dev.connected ? true : (Math.random() > 0.8),
                battery: dev.battery ? Math.max(0, Math.min(100, dev.battery + Math.floor(Math.random() * 10) - 5)) : null
              }));
            },
              renderDevices: (container) => {
              const list = container.querySelector('.device-list');
              list.innerHTML = 'Scanning...';
              setTimeout(() => {
                list.innerHTML = '';
                const devices = AppManager.apps.bluetoothManager.getSimulatedDevices();
                if (devices.length === 0) {
                  list.innerHTML = '<li>No Bluetooth devices found.</li>';
                  return;
                }
                devices.forEach(dev => {
                  const item = document.createElement('li');
                  item.innerHTML = `<span>${dev.name} (Type: ${dev.type})</span>
                                ${dev.battery !== null ? `<span class="text-xs text-gray-600 ml-2">Batt: ${dev.battery}%</span>` : ''}
                                ${dev.connected ? `<span class="text-green-500 ml-2">Connected</span>` : `<button data-devname="${dev.name}" class="pair-btn px-2 py-0.5 bg-green-500 text-white text-xs rounded hover:bg-green-600 ml-auto">Pair</button>`}`;
                  if (!dev.connected) {
                    item.querySelector('.pair-btn').onclick = async (e) => {
                      const devName = e.target.dataset.devname;
                      const hasPerm = await OBPI.kernel.requestPermission('bluetooth_pair', 'BluetoothManagerApp');
                      if(hasPerm) AppManager.cliCommands.bt(['pair', devName]);
                      else Modal.show("Permission Denied", "Bluetooth pair permission was not granted.");
                    };
                  }
                  list.appendChild(item);
                });
              }, 1000);
            }
          },
          peripheralManager: { // NEW APP: Peripheral Manager
            init: () => {
              const content = document.createElement('div');
              content.innerHTML = `
                        <h3 class="text-lg font-semibold mb-3">Peripheral Manager</h3>
                        <div class="mb-4">
                            <h4 class="font-medium mb-2">USB Devices</h4>
                            <button id="scan-usb-btn" class="px-3 py-1.5 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm mb-2">Scan USB Devices</button>
                            <ul id="usb-device-list" class="device-list"><li>Click 'Scan USB Devices' to find devices.</li></ul>
                        </div>
                        <div class="mb-4">
                            <h4 class="font-medium mb-2">Camera Devices</h4>
                            <button id="scan-camera-btn" class="px-3 py-1.5 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm mb-2">Scan Cameras</button>
                            <ul id="camera-device-list" class="device-list"><li>Click 'Scan Cameras' to find devices.</li></ul>
                        </div>
                        <div>
                            <h4 class="font-medium mb-2">Microphone Devices</h4>
                            <button id="scan-mic-btn" class="px-3 py-1.5 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm mb-2">Scan Microphones</button>
                            <ul id="mic-device-list" class="device-list"><li>Click 'Scan Microphones' to find devices.</li></ul>
                        </div>
                        <div class="mt-4">
                            <h4 class="font-medium mb-2">Virtual Driver Status (USB-C Hub to HDMI)</h4>
                            <div id="virtual-driver-status" class="bg-gray-100 p-3 rounded text-gray-800 text-sm">Loading status...</div>
                        </div>
                    `;
              content.querySelector('#scan-usb-btn').onclick = () => AppManager.apps.peripheralManager.scanUsbDevices(content.querySelector('#usb-device-list'));
              content.querySelector('#scan-camera-btn').onclick = () => AppManager.apps.peripheralManager.scanCameraDevices(content.querySelector('#camera-device-list'));
              content.querySelector('#scan-mic-btn').onclick = () => AppManager.apps.peripheralManager.scanMicrophoneDevices(content.querySelector('#mic-device-list'));
              AppManager.apps.peripheralManager.loadVirtualDriverStatus(content.querySelector('#virtual-driver-status'));
              return content;
            },
              loadVirtualDriverStatus: async (element) => {
              try {
                const response = await window.pywebview.api.get_system_info_backend();
                if (response.error) {
                  element.innerHTML = `<p class="text-red-500">Error loading virtual driver status: ${response.error}</p>`;
                  return;
                }
                const status = response.usb_c_hdmi_driver_status;
                if (status && status.status) {
                  element.innerHTML = `
                                <p><strong>Device:</strong> ${status.device_name}</p>
                                <p><strong>Status:</strong> <span class="${status.status === 'active' ? 'text-green-600' : 'text-red-600'}">${status.status.toUpperCase()}</span></p>
                                <p><strong>Display Out:</strong> ${status.display_out}</p>
                                <p><strong>Driver Version:</strong> ${status.driver_version}</p>
                                <p><strong>USB Ports:</strong></p>
                                <ul class="list-disc list-inside ml-4">
                                    <li>USB-A 2.0 (Keyboard/Mouse): ${status.ports.usb_a_2_0_kb_mouse}</li>
                                    <li>USB-A 3.0 (HDD): ${status.ports.usb_a_3_0_hdd}</li>
                                    <li>USB-C PD 3.0 (Power): ${status.ports.usb_c_pd_3_0_power}</li>
                                </ul>
                                <p class="text-xs text-gray-600 mt-2"><em>${status.notes}</em></p>
                            `;
                } else {
                  element.innerHTML = `<p class="text-red-500">Virtual driver status not available.</p>`;
                }
              } catch (e) {
                element.innerHTML = `<p class="text-red-500">Communication error loading virtual driver status: ${e.message}</p>`;
                OBPI.kernel.log(`Virtual Driver Status Error: ${e.stack}`, 'error');
              }
            },
              scanUsbDevices: async (listElement) => {
              listElement.innerHTML = '<li>Scanning USB devices...</li>';
              try {
                const response = await window.pywebview.api.get_usb_devices_backend();
                if (response.error) {
                  listElement.innerHTML = `<li>Error: ${response.error}</li>`;
                  return;
                }
                const devices = response.devices || [];
                if (devices.length === 0) {
                  listElement.innerHTML = '<li>No USB devices found.</li>';
                } else {
                  listElement.innerHTML = '';
                  devices.forEach(device => {
                    const item = document.createElement('li');
                    item.className = 'device-list-item';
                    item.innerHTML = `<span>${device.product || 'Unknown Device'} (${device.device_type})</span>
                                    <span class="status text-gray-600">VID: ${device.vendor_id}, PID: ${device.product_id}</span>`;
                    if (device.manufacturer && device.manufacturer !== "N/A") item.innerHTML += `<br><span class="text-xs text-gray-500 ml-4">Mfg: ${device.manufacturer}</span>`;
                    if (device.serial_number && device.serial_number !== "N/A") item.innerHTML += `<br><span class="text-xs text-gray-500 ml-4">Serial: ${device.serial_number}</span>`;
                    listElement.appendChild(item);
                  });
                }
              } catch (e) {
                listElement.innerHTML = `<li>Backend communication error: ${e.message}</li>`;
                OBPI.kernel.log(`Peripheral Manager USB Scan Error: ${e.stack}`, 'error');
              }
            },
              scanCameraDevices: async (listElement) => {
              listElement.innerHTML = '<li>Scanning cameras...</li>';
              try {
                const response = await window.pywebview.api.get_camera_devices_backend();
                if (response.error) {
                  listElement.innerHTML = `<li>Error: ${response.error}</li>`;
                  return;
                }
                const devices = response.devices || [];
                if (devices.length === 0) {
                  listElement.innerHTML = '<li>No camera devices found.</li>';
                } else {
                  listElement.innerHTML = '';
                  devices.forEach(device => {
                    const item = document.createElement('li');
                    item.className = 'device-list-item';
                    item.innerHTML = `<span>${device.name}</span> <span class="status text-gray-600">Status: ${device.status}</span>`;
                    listElement.appendChild(item);
                  });
                }
              } catch (e) {
                listElement.innerHTML = `<li>Backend communication error: ${e.message}</li>`;
                OBPI.kernel.log(`Peripheral Manager Camera Scan Error: ${e.stack}`, 'error');
              }
            },
              scanMicrophoneDevices: async (listElement) => {
              listElement.innerHTML = '<li>Scanning microphones...</li>';
              try {
                const response = await window.pywebview.api.get_microphone_devices_backend();
                if (response.error) {
                  listElement.innerHTML = `<li>Error: ${response.error}</li>`;
                  return;
                }
                const devices = response.devices || [];
                if (devices.length === 0) {
                  listElement.innerHTML = '<li>No microphone devices found.</li>';
                } else {
                  listElement.innerHTML = '';
                  devices.forEach(device => {
                    const item = document.createElement('li');
                    item.className = 'device-list-item';
                    item.innerHTML = `<span>${device.name}</span> <span class="status text-gray-600">Status: ${device.status}</span>`;
                    listElement.appendChild(item);
                  });
                }
              } catch (e) {
                listElement.innerHTML = `<li>Backend communication error: ${e.message}</li>`;
                OBPI.kernel.log(`Peripheral Manager Mic Scan Error: ${e.stack}`, 'error');
              }
            }
          },
          themeSettings: {
            launch: () => { const content = document.createElement('div'); content.innerHTML = ` <h3 class="text-lg font-semibold mb-3">Theme Settings</h3> <p class="mb-2 text-sm">Select a theme for the OBPI interface.</p> <div class="flex gap-4"> <button data-theme="dark" class="theme-btn px-4 py-2 bg-gray-700 text-white rounded hover:bg-gray-600">Dark Theme</button> <button data-theme="light" class="theme-btn px-4 py-2 bg-gray-200 text-black rounded hover:bg-gray-300">Light Theme</button> </div> `; content.querySelectorAll('.theme-btn').forEach(btn => { btn.onclick = () => AppManager.apps.themeSettings.setTheme(btn.dataset.theme); }); WindowManager.create('theme-settings', 'Theme Settings', content, {width: '400px', height:'250px'}); },
              setTheme: (themeName) => { document.body.classList.remove('light-theme', 'dark-theme'); if (themeName === 'light') { document.body.classList.add('light-theme'); OBPI.activeTheme = 'light'; } else { OBPI.activeTheme = 'dark'; } localStorage.setItem(OBPI.config.themeStorageKey, OBPI.activeTheme); OBPI.kernel.log(`Theme changed to ${OBPI.activeTheme}`); if (Terminal.promptElement) Terminal.updatePrompt(); DesktopIcons.render(); },
              loadTheme: () => { const savedTheme = localStorage.getItem(OBPI.config.themeStorageKey); if (savedTheme) AppManager.apps.themeSettings.setTheme(savedTheme); else AppManager.apps.themeSettings.setTheme('dark'); }
          },
          pepxExplorer: {
            fileManager: null,
              init: () => {
              const content = document.createElement('div');
              content.style.width = '100%';
              content.style.height = '100%';
              content.style.overflow = 'hidden';

              if (!OBPI.pepxInstance) {
                OBPI.pepxInstance = new PEPxStorage();
                OBPI.pepxInstance.initialize().then(() => { // Initialize PEPx storage (loads metadata)
                  if (AppManager.apps.pepxExplorer.fileManager) {
                    AppManager.apps.pepxExplorer.fileManager.refreshFileList();
                  }
                }).catch(err => OBPI.kernel.log("Error initializing PEPx storage for explorer: " + err, "error"));
              }

              AppManager.apps.pepxExplorer.fileManager = new PEPxFileManager(OBPI.pepxInstance);
              AppManager.apps.pepxExplorer.fileManager.initUI(content);

              // Load some mock files into PEPx for demo if its metadata is empty
              // This will now trigger backend storage of raw data as well
              OBPI.pepxInstance.metadataStore.loadFromBackend().then(() => {
                if (Object.keys(OBPI.pepxInstance.metadataStore.files).length === 0) {
                  OBPI.kernel.log("Adding mock PEPx files for demonstration...", "info");
                  const mockFiles = [
                    { name: 'PixelDocs', path: '/', type: 'folder', size: 0 },
                    { name: 'SampleImage.png', path: '/PixelDocs', type: 'image/png', size: 1024 * 50, rawData: btoa("This is a small simulated image data string.") },
                    { name: 'EncodedText.txt', path: '/PixelDocs', type: 'text/plain', size: 100, rawData: btoa("This is some text encoded in pixels.") }
                  ];
                  mockFiles.forEach(async (f) => {
                    const fileId = OBPI.pepxInstance.generateUniqueId();
                    const metadata = { ...f, id: fileId, storedByteLength: f.rawData ? atob(f.rawData).length : 0, created: new Date().toISOString(), modified: new Date().toISOString() };

                    if (f.rawData) {
                      await window.pywebview.api.pepx_store_raw_data_backend(fileId, f.rawData);
                      delete metadata.rawData; // Don't store rawData in metadata
                    }
                    OBPI.pepxInstance.metadataStore.addFile(metadata);
                  });
                  AppManager.apps.pepxExplorer.fileManager.refreshFileList();
                }
              });

              return content;
            }
          }
        }
        };

          // --- DecHex Language Interpreter (Remains client-side) ---
          const DecHexLang = {
            memory: new Uint8Array(256), stack: [],
            interpret: (hexString) => { let acc = 0, pc = 0, flags = { zero: false }; let output = ""; DecHexLang.stack = []; DecHexLang.memory.fill(0); const code = hexString.replace(/\s/g, '').match(/.{1,2}/g)?.map(byte => parseInt(byte, 16)) || []; if (hexString.replace(/\s/g, '').length % 2 !== 0) throw new Error("Invalid hex string length."); while (pc < code.length) { const op = code[pc++]; switch (op) { case 0x0A: acc += code[pc++]; break; case 0x0B: acc -= code[pc++]; break; case 0x0C: output += `ACC: ${acc} (0x${acc.toString(16).padStart(2,'0')})\n`; break; case 0x0D: acc = code[pc++]; break; case 0x0E: DecHexLang.stack.push(acc); break; case 0x0F: if(DecHexLang.stack.length === 0) throw new Error("Stack underflow"); acc = DecHexLang.stack.pop(); break; case 0x10: if(DecHexLang.stack.length === 0) throw new Error("Stack empty for peek"); output += `STACK_PEEK: ${DecHexLang.stack[DecHexLang.stack.length-1]}\n`; break; case 0x11: const jmpAddr = code[pc++]; if (acc === 0) pc = jmpAddr; flags.zero = (acc === 0); break; case 0x12: const memAddrStore = code[pc++]; if(memAddrStore >= DecHexLang.memory.length) throw new Error(`Memory out of bounds: ${memAddrStore}`); DecHexLang.memory[memAddrStore] = acc & 0xFF; output += `Stored ${acc & 0xFF} to MEM[${memAddrStore}]\n`; break; case 0x13: const memAddrLoad = code[pc++]; if(memAddrLoad >= DecHexLang.memory.length) throw new Error(`Memory out of bounds: ${memAddrLoad}`); acc = DecHexLang.memory[memAddrLoad]; output += `Loaded ${acc} from MEM[${memAddrLoad}] to ACC\n`; break; case undefined: throw new Error("Unexpected end of code (operand missing)."); default: throw new Error(`Unknown OpCode: 0x${op.toString(16).padStart(2,'0')} at PC=${pc-1}`); } if (acc > 255) acc = 255; if (acc < 0) acc = 0; } return output.trim() || `Execution complete. Final ACC: ${acc}`; }
          };

          // --- Desktop Icons Module ---
          const DesktopIcons = {
            icons: [],
            load: () => { const storedIcons = localStorage.getItem(OBPI.config.desktopIconStorageKey); if (storedIcons) { try { DesktopIcons.icons = JSON.parse(storedIcons); } catch (e) { OBPI.kernel.log("Error parsing desktop icons from localStorage", "error"); DesktopIcons.setDefaultIcons(); } } else { DesktopIcons.setDefaultIcons(); } DesktopIcons.render(); },
            save: () => { try { localStorage.setItem(OBPI.config.desktopIconStorageKey, JSON.stringify(DesktopIcons.icons)); } catch (e) { OBPI.kernel.log("Error saving desktop icons to localStorage", "error"); } },
            setDefaultIcons: () => { DesktopIcons.icons = [ { id: 'icon-terminal', name: 'Terminal', icon: '🖥️', action: 'terminal', type: 'app' }, { id: 'icon-webview', name: 'Web View', icon: '🌐', action: 'web_view', type: 'app' }, { id: 'icon-pyide', name: 'Python IDE', icon: '🐍', action: 'py_ide', type: 'app' }, { id: 'icon-pepx', name: 'PEPx Explorer', icon: '🖼️', action: 'pepx_explorer', type: 'app' }, { id: 'icon-peripheral-manager', name: 'Peripherals', icon: '🔌', action: 'peripheral_manager', type: 'app' }, { id: 'icon-readme', name: 'README.txt', icon: '📄', action: '/home/guest/readme.txt', type: 'file' } ]; DesktopIcons.save(); },
            add: (name, iconChar, action, type = 'app') => { const id = `icon-${name.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`; DesktopIcons.icons.push({ id, name, icon: iconChar, action, type }); DesktopIcons.save(); DesktopIcons.render(); },
            remove: (id) => { DesktopIcons.icons = DesktopIcons.icons.filter(icon => icon.id !== id); DesktopIcons.save(); DesktopIcons.render(); },
            render: () => { Array.from(OBPI.desktopElement.children).forEach(child => { if (child.id !== 'webgl-canvas' && child.id !== 'fullscreen-lock-overlay' && !child.classList.contains('os-window')) child.remove(); }); DesktopIcons.icons.forEach(iconData => { const iconEl = document.createElement('div'); iconEl.className = 'desktop-icon'; iconEl.title = iconData.name; iconEl.dataset.id = iconData.id; iconEl.dataset.action = iconData.action; iconEl.dataset.type = iconData.type; if (iconData.icon.startsWith('<svg>') || iconData.icon.includes('/')) iconEl.innerHTML = `<img src="${iconData.icon}" alt="${iconData.name}"><span>${iconData.name}</span>`; else iconEl.innerHTML = `<div class="icon-placeholder">${iconData.icon}</div><span>${iconData.name}</span>`; iconEl.ondblclick = () => { if (iconData.type === 'app') AppManager.cliCommands.run([iconData.action]); else if (iconData.type === 'file') AppManager.cliCommands.exec([iconData.action]); }; iconEl.draggable = true; iconEl.ondragstart = (e) => { e.dataTransfer.setData('text/plain', iconData.id); }; OBPI.desktopElement.appendChild(iconEl); }); }
          };
          OBPI.desktopElement.ondragover = (e) => e.preventDefault();
          OBPI.desktopElement.ondrop = (e) => { e.preventDefault(); };


          // --- Context Menu Setup ---
          function setupContextMenu() {
            const items = [ { label: 'Create Folder...', action: 'create-folder', icon: '📁' }, { label: 'Create Shortcut...', action: 'create-shortcut', icon: '🔗' }, { label: 'Terminal Settings', action: 'term-settings', icon: '⚙️' }, { label: 'Change Background...', action: 'change-bg', icon: '🖼️' }, {label: 'Toggle Theme', action: 'toggle-theme', icon: '🎨'}, { label: 'System Info', action: 'sys-info', icon: 'ℹ️' }, { label: 'Reset OBPI (DANGER)', action: 'reset-obpi', icon: '⚠️' } ]; OBPI.contextMenuElement.innerHTML = ''; items.forEach(item => { const menuItem = document.createElement('div'); menuItem.className = 'context-menu-item'; menuItem.innerHTML = `<span class="mr-2">${item.icon}</span> ${item.label}`; menuItem.onclick = () => { OBPI.contextMenuElement.classList.add('hidden'); handleContextMenuAction(item.action); }; OBPI.contextMenuElement.appendChild(menuItem); }); OBPI.desktopElement.oncontextmenu = (e) => { e.preventDefault(); OBPI.contextMenuElement.style.top = `${e.clientY}px`; OBPI.contextMenuElement.style.left = `${e.clientX}px`; OBPI.contextMenuElement.classList.remove('hidden'); }; document.onclick = (e) => { if (!OBPI.contextMenuElement.contains(e.target) && !e.target.closest('#start-menu-button') && !e.target.closest('#start-menu')) OBPI.contextMenuElement.classList.add('hidden'); };
          }
          async function handleContextMenuAction(action) { // Made async
            switch(action) {
              case 'create-folder': Modal.prompt('Create Folder', 'Enter folder name:', 'NewFolder', (name) => { if (name) AppManager.cliCommands.mkdir([name]); }); break;
              case 'create-shortcut':  Modal.prompt('Create Shortcut', 'Enter App ID or File Path for shortcut:', 'web_view', (target) => { if (target) { const name = prompt("Enter shortcut name:", target.split('/').pop() || target); if (name) { const type = AppManager.installedApps[target] ? 'app' : 'file'; const icon = AppManager.installedApps[target]?.icon || (type === 'file' ? '📄' : '🚀'); DesktopIcons.add(name, icon, target, type); } } }); break;
              case 'term-settings': Modal.show('Terminal Settings', 'Terminal settings are conceptual for now.'); break;
              case 'change-bg': Modal.show('Change Background', 'Background customization is planned for a future version.'); break;
              case 'toggle-theme': AppManager.apps.themeSettings.setTheme(OBPI.activeTheme === 'dark' ? 'light' : 'dark'); break;
              case 'sys-info':
                Terminal.print("Fetching System Information...", false, 'info');
                const response = await window.pywebview.api.get_system_info_backend();
                if (response.error) {
                  Modal.show('System Information Error', `Failed to retrieve system info: ${response.error}`);
                  return;
                }
                let sysInfoContent = '<ul>';
                for (const key in response) {
                  sysInfoContent += `<li><strong>${key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase())}:</strong> ${response[key]}</li>`;
                }
                sysInfoContent += '</ul>';
                Modal.show('System Information', sysInfoContent);
                break;
              case 'reset-obpi': AppManager.cliCommands.fs_reset(); break;
              default: OBPI.kernel.log(`Unknown context menu action: ${action}`, 'warn');
            }
          }

          // --- Start Menu ---
          function setupStartMenu() {
            OBPI.startMenuButton.onclick = (e) => { e.stopPropagation(); OBPI.startMenuElement.classList.toggle('hidden'); }; document.addEventListener('click', (e) => { if (!OBPI.startMenuElement.contains(e.target) && e.target !== OBPI.startMenuButton) OBPI.startMenuElement.classList.add('hidden'); }); renderStartMenuItems();
          }
          function renderStartMenuItems() {
            OBPI.startMenuElement.innerHTML = ''; Object.entries(AppManager.installedApps).forEach(([id, app]) => { const item = document.createElement('a'); item.href = '#'; item.className = 'start-menu-item'; item.innerHTML = `<span class="mr-2">${app.icon || '🔹'}</span>${app.name}`; item.onclick = (e) => { e.preventDefault(); app.launch(); OBPI.startMenuElement.classList.add('hidden'); }; OBPI.startMenuElement.appendChild(item); }); const settingsItem = document.createElement('a'); settingsItem.href = '#'; settingsItem.className = 'start-menu-item mt-2 border-t border-gray-700 pt-2'; settingsItem.innerHTML = `<span class="mr-2">⚙️</span>Theme Settings`; settingsItem.onclick = (e) => { e.preventDefault(); AppManager.installedApps['theme_settings'].launch(); OBPI.startMenuElement.classList.add('hidden'); }; OBPI.startMenuElement.appendChild(settingsItem);
          }

          // --- Initialization Function ---
          async function main() { // Made async to await PEPx storage initialization
            OBPI.kernel.log(`Initializing ${OBPI.name} v${OBPI.version}...`);
            AppManager.apps.themeSettings.loadTheme();
            initWebGLBackground();
            OBPI.envVars['HOME'] = '/home/guest/';
            OBPI.envVars['USER'] = 'guest';
            OBPI.envVars['PATH'] = '/bin:/home/guest/bin';
            WindowManager.restoreAllWindowStates();
            Terminal.init();
            setupContextMenu();
            setupStartMenu();
            DesktopIcons.load();

            // Initialize PEPx storage (loads metadata and prepares for raw data storage)
            OBPI.pepxInstance = new PEPxStorage();
            await OBPI.pepxInstance.initialize();

            // Create initial VFS structure if it's empty (only on first run after full reset)
            try {
              const lsResponse = await window.pywebview.api.list_directory_backend('/');
              if (lsResponse.error || lsResponse.contents.length === 0) {
                OBPI.kernel.log("VFS appears empty or inaccessible. Initializing default structure...", "info");
                // Create default directories
                await window.pywebview.api.create_directory_backend('/home');
                await window.pywebview.api.create_directory_backend('/home/guest');
                await window.pywebview.api.create_directory_backend('/home/guest/Desktop');
                await window.pywebview.api.create_directory_backend('/home/guest/documents');
                await window.pywebview.api.create_directory_backend('/home/guest/downloads');
                await window.pywebview.api.create_directory_backend('/home/guest/python_scripts');
                await window.pywebview.api.create_directory_backend('/bin');
                await window.pywebview.api.create_directory_backend('/etc');
                await window.pywebview.api.create_directory_backend('/tmp');

                // Create default files
                await window.pywebview.api.write_file_backend('/home/guest/documents/project_plan_v1.0.txt', `Project Plan for OBPI v${OBPI.version}\n- Full Pywebview Integration\n- Persistent File System\n- Embedded Browser with History/Bookmarks\n- Complete Python IDE\n- PEPx Raw Data Storage (no canvas)\n- Real USB Peripheral Detection\n- Conceptual Compiler Framework\n- Enhanced AI Assistant`);
                await window.pywebview.api.write_file_backend('/home/guest/python_scripts/hello.py', `print("Hello from Python in OBPI!")\nprint("This script is managed by the backend VFS.")`);
                await window.pywebview.api.write_file_backend('/home/guest/python_scripts/example.obsh', `echo "Running OBPI Shell Script"\ndate\nls /home/guest/python_scripts`);
                await window.pywebview.api.write_file_backend('/home/guest/readme.txt', `Welcome to OBPI (${OBPI.name}) v${OBPI.version}!\nThis is a fully integrated virtual machine environment.\nAll changes to the file system are persisted on your host machine.`);
                await window.pywebview.api.write_file_backend('/etc/obpi.config', `version=${OBPI.version}\nprompt=${OBPI.config.defaultPrompt}\ntheme=${OBPI.activeTheme}`);
                await window.pywebview.api.write_file_backend('/etc/hosts.sim', '127.0.0.1 localhost.obpi\n10.0.0.1 virtual.server.obpi');
                await window.pywebview.api.write_file_backend('/bin/curl', '#!/bin/simulated_executable\n# curl command');
                await window.pywebview.api.write_file_backend('/bin/wget', '#!/bin/simulated_executable\n# wget command');
                await window.pywebview.api.write_file_backend('/bin/exec', '#!/bin/simulated_executable\n# exec command');
                await window.pywebview.api.write_file_backend('/bin/mv', '#!/bin/simulated_executable\n# mv command');
                await window.pywebview.api.write_file_backend('/bin/cp', '#!/bin/simulated_executable\n# cp command');
                await window.pywebview.api.write_file_backend('/bin/pkg_build', '#!/bin/obsh\n# pkg_build command - see help pkg_build');
                await window.pywebview.api.write_file_backend('/bin/process_list', '#!/bin/obsh\n# process_list command - see help process_list');
                await window.pywebview.api.write_file_backend('/bin/resource_monitor', '#!/bin/obsh\n# resource_monitor command - see help resource_monitor');
                await window.pywebview.api.write_file_backend('/bin/usb_scan', '#!/bin/obsh\n# usb_scan command - see help usb_scan');
                await window.pywebview.api.write_file_backend('/bin/c_compile', '#!/bin/obsh\n# c_compile command - see help c_compile');
                await window.pywebview.api.write_file_backend('/bin/cpp_compile', '#!/bin/obsh\n# cpp_compile command - see help cpp_compile');
                await window.pywebview.api.write_file_backend('/bin/csharp_compile', '#!/bin/obsh\n# csharp_compile command - see help csharp_compile');
                await window.pywebview.api.write_file_backend('/bin/go_compile', '#!/bin/obsh\n# go_compile command - see help go_compile');
                await window.pywebview.api.write_file_backend('/bin/rust_compile', '#!/bin/obsh\n# rust_compile command - see help rust_compile');
                await window.pywebview.api.write_file_backend('/bin/haskell_compile', '#!/bin/obsh\n# haskell_compile command - see help haskell_compile');
                await window.pywebview.api.write_file_backend('/bin/cobol_compile', '#!/bin/obsh\n# cobol_compile command - see help cobol_compile');
                await window.pywebview.api.write_file_backend('/bin/fortran_compile', '#!/bin/obsh\n# fortran_compile command - see help fortran_compile');
                await window.pywebview.api.write_file_backend('/bin/lua_run', '#!/bin/obsh\n# lua_run command - see help lua_run');
                await window.pywebview.api.write_file_backend('/bin/emcc_compile', '#!/bin/obsh\n# emcc_compile command - see help emcc_compile');
                await window.pywebview.api.write_file_backend('/bin/hex_to_webgl', '#!/bin/obsh\n# hex_to_webgl command - see help hex_to_webgl');


                Terminal.print("Default VFS structure initialized.", "success");
              }
            } catch (e) {
              OBPI.kernel.log(`Error during initial VFS setup: ${e.message}`, "error");
              Terminal.print(`Error during initial VFS setup: ${e.message}`, false, 'error');
            }


            if (!OBPI.windows['welcome-note']) {
              WindowManager.create('welcome-note', `Welcome to ${OBPI.name}!`,
                `<div class="p-3"> <h2 class="text-xl font-semibold mb-2">${OBPI.name} v${OBPI.version}</h2> <p class="text-sm mb-1">This is a fully functional virtual machine desktop environment.</p> <p class="text-sm mb-1">All data (files, browser history, bookmarks, PEPx metadata) is now persistently stored on your host machine.</p> <p class="text-sm">Explore the Python IDE, embedded browser, and peripheral manager. Right-click desktop for options. Click OBPI button for Start Menu. Type 'help' in terminal.</p> <p class="text-xs mt-3 text-gray-500">Timestamp: ${new Date().toISOString()}</p> </div>`,
                { width: '600px', height: '380px', top: '50px', left: '50px' }
              );
            }
            if (!OBPI.windows['terminal']) { if (OBPI.windows['terminal']) WindowManager.focus('terminal'); }

            document.addEventListener('fullscreenchange', () => { if (!document.fullscreenElement) { OBPI.isLocked = false; OBPI.fullscreenLockOverlay.style.display = 'none'; OBPI.kernel.log("Exited fullscreen mode.", "info"); } else { OBPI.isLocked = true; OBPI.fullscreenLockOverlay.style.display = 'block'; OBPI.kernel.log("Entered fullscreen mode.", "info"); } });
            document.addEventListener('webkitfullscreenchange', () => { if (!document.webkitFullscreenElement) { OBPI.isLocked = false; OBPI.fullscreenLockOverlay.style.display = 'none'; } else { OBPI.isLocked = true; OBPI.fullscreenLockOverlay.style.display = 'block'; } });

            OBPI.kernel.log(`${OBPI.name} fully initialized and ready.`, "success");
          }

          function ensureHttps(url) { if (!/^https?:\/\//i.test(url)) return 'https://' + url; return url; }

          document.addEventListener('DOMContentLoaded', main);
</pyscript>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="js/webgl-init-fixed.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</script>
</body>
</html>
